{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/DS-Lecture3 VMware.md","hash":"cfb8748547fbe7e8fcb973c3e251ea9b4b848f45","modified":1696489500952},{"_id":"source/_posts/DS-Lecture4 Raft.md","hash":"56bd1cee01719d8629bd5f142e5872991fc70023","modified":1696731582818},{"_id":"source/_posts/多状态DP.md","hash":"af771fbe83edaebd7f5af3b8572ba19d806c086f","modified":1696056539996},{"_id":"source/_posts/DS_Lecture1 mapreduce.md","hash":"7a24b19a1dd619e822db9122658438d433bcd46a","modified":1696056696269},{"_id":"source/_posts/保证不重复的dp.md","hash":"f643e59d31fff7a8000dbaa140368b3b0dd92396","modified":1696386987710},{"_id":"source/_posts/DS_Lecture2 GFS.md","hash":"a9e4a2ac1f75e2c5b28bdb20def726461d21e9a4","modified":1696218220484},{"_id":"source/_posts/算法：单调队列.md","hash":"95a581ef1637e54795221daf88b8b8a68feed198","modified":1694963112095},{"_id":"source/about/index.md","hash":"469e66599383ff638fc05f6e42c4bc1463a464e7","modified":1696057817346},{"_id":"source/tags/index.md","hash":"e87e2b2441ed9b3f95b4f7abd6ff2285ad92ea5f","modified":1696058172606},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1696057241970},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1696057241964},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1696057241964},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1696057241970},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1696057241970},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1696057241964},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1696057241971},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1696057241973},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1696057242023},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1696057241971},{"_id":"themes/next/_config.yml","hash":"cd1a6c14db2186b07d61753bff8ba34f55dfb7a0","modified":1696496604393},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1696057241964},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1696057241967},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1696057241965},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1696057241984},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1696057241968},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1696057241968},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1696057241968},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1696057241967},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1696057241969},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1696057241969},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1696057241969},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1696057241970},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1696057241974},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1696057241973},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1696057241975},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1696057241974},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1696057241977},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1696057241977},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1696057241975},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1696057241977},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1696057241985},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1696057241978},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1696057241984},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1696057241984},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1696057241985},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1696057241985},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1696057241986},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1696057241986},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1696057241987},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1696057241987},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1696057241987},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1696057241989},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1696057241988},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1696057241989},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1696057241989},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1696057241990},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1696057241989},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1696057241989},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1696057241991},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1696057241991},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1696057241992},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1696057241991},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1696057241991},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1696057242022},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1696057241992},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1696057242022},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1696057242021},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1696057242033},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1696057242023},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1696057242023},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1696057242022},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1696057241966},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1696057241966},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1696057241965},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1696057241967},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1696057241980},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1696057241978},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1696057241979},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1696057241978},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1696057241979},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1696057241981},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1696057241981},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1696057241980},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1696057241981},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1696057241982},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1696057241983},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1696057241982},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1696057241994},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1696057241983},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1696057241993},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1696057241993},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1696057242005},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1696057242008},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1696057242005},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1696057242006},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1696057242008},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1696057241995},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1696057241999},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1696057242000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1696057242015},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1696057242004},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1696057242024},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1696057241994},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1696057242032},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1696057242032},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1696057242032},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1696057242033},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1696057242030},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1696057242030},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1696057242030},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1696057242031},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1696057242011},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1696057242031},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1696057242037},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1696057242016},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1696057242034},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1696057242034},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1696057242034},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1696057242035},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1696057242035},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1696057242036},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1696057242035},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1696057242036},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1696057242036},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1696057242037},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1696057242016},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1696057242073},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1696057242078},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1696057242063},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1696057242079},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1696057242079},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1696057242079},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1696057242074},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1696057242080},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1696057242073},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1696057242074},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1696057242075},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1696057242075},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1696057242081},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1696057242076},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1696057242078},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1696057242076},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1696057242074},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1696057242076},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1696057242078},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1696057242078},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1696057242078},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1696057241996},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1696057241995},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1696057242007},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1696057242008},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1696057242007},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1696057242007},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1696057242006},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1696057241997},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1696057241997},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1696057242083},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1696057241997},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1696057241998},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1696057242000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1696057241998},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1696057242001},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1696057241999},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1696057242000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1696057242001},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1696057242002},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1696057242002},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1696057242003},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1696057242003},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1696057242004},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1696057242003},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1696057242009},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1696057242011},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1696057242010},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1696057242011},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1696057242010},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1696057242013},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1696057242014},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1696057242014},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1696057242015},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1696057242013},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1696057242015},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1696057242014},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1696057242017},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1696057242017},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1696057242013},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1696057242018},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1696057242016},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1696057242019},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1696057242018},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1696057242025},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1696057242025},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1696057242025},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1696057242020},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1696057242027},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1696057242027},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1696057242021},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1696057242027},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1696057242028},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1696057242027},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1696057242028},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1696057242029},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1696057242029},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1696057242019},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1696057242021},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1696057242071},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1696057242072},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1696057242020},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1696057242071},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1696057242072},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1696057242072},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1696057242080},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1696057242081},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1696057242086},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1696057242038},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1696057242038},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1696057242038},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1696057242086},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1696057242051},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1696057242051},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1696057242046},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1696057242056},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1696057242059},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1696057242058},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1696057242059},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1696057242055},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1696057242056},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1696057242060},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1696057242063},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1696057242065},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1696057242065},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1696057242065},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1696057242066},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1696057242066},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1696057242066},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1696057242067},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1696057242067},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1696057242067},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1696057242068},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1696057242068},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1696057242069},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1696057242069},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1696057242069},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1696057242070},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1696057242064},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1696057242070},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1696057242070},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1696057242083},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1696057242084},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1696057242039},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1696057242039},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1696057242040},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1696057242040},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1696057242040},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1696057242041},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1696057242041},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1696057242042},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1696057242042},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1696057242043},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1696057242043},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1696057242044},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1696057242044},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1696057242044},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1696057242043},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1696057242045},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1696057242045},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1696057242045},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1696057242048},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1696057242049},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1696057242049},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1696057242050},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1696057242049},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1696057242050},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1696057242050},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1696057242046},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1696057242046},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1696057242047},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1696057242047},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1696057242047},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1696057242052},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1696057242048},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1696057242052},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1696057242052},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1696057242053},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1696057242053},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1696057242053},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1696057242054},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1696057242054},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1696057242055},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1696057242054},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1696057242057},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1696057242058},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1696057242057},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1696057242060},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1696057242057},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1696057242060},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1696057242061},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1696057242062},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1696057242062},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1696057242062},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1696057242012},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1696057242063},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1696057242085},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1696057242084},{"_id":"public/tags/index.html","hash":"5869ea8c946c17e1a6ae3392627e24a802c0ce3d","modified":1696496713174},{"_id":"public/about/index.html","hash":"32c91bd5d32aae282c34beef9331f7acaae65088","modified":1696496713174},{"_id":"public/2023/10/05/DS-Lecture4 Raft/index.html","hash":"bd2a1b0c74e80130d52f08bfeb8d79a225ea3051","modified":1696756958630},{"_id":"public/2023/10/04/保证不重复的dp/index.html","hash":"2502e6e790a968b32cb1d752618ccf5df793f6bf","modified":1696496713174},{"_id":"public/archives/2023/index.html","hash":"17e3c0e173aa71ea4ede8595d9d166660c5fef19","modified":1696496713174},{"_id":"public/archives/index.html","hash":"242235cba14672a2aab3bceedb3d25525899cf71","modified":1696496713174},{"_id":"public/archives/2023/09/index.html","hash":"4df27477d616a35f76f598e083cb6e048a0697b4","modified":1696496713174},{"_id":"public/archives/2023/10/index.html","hash":"9d9488f4821c30856a4543131687c02abe1187bf","modified":1696496713174},{"_id":"public/tags/mit-6-824/index.html","hash":"bea2a1f735e211b4e8e6add59f2007fe12d5a45e","modified":1696496713174},{"_id":"public/tags/容错/index.html","hash":"c328d8f24825b296555b22c3bf29d65b91aa6492","modified":1696496713174},{"_id":"public/tags/算法/index.html","hash":"e6294e25a9027bdafb85022b5db0222457be93e3","modified":1696496713174},{"_id":"public/tags/DP/index.html","hash":"c350c66a0b241ad46f4e3076bb2cc983b20cbd1f","modified":1696496713174},{"_id":"public/tags/Raft/index.html","hash":"84ea25fc78434c3e350fd3768e931d268016ad6d","modified":1696496713174},{"_id":"public/tags/分布式系统/index.html","hash":"5ac79b43831d0efbe6a7bc5f1fc77b20cba9ec5d","modified":1696496713174},{"_id":"public/tags/GFS/index.html","hash":"4a3b6eb39ab61970b920541e88edd206c82dd714","modified":1696496713174},{"_id":"public/tags/MapReduce/index.html","hash":"392991da6813b2dfbd7ea1ec8da10c54f72a0ee3","modified":1696496713174},{"_id":"public/2023/10/03/DS-Lecture3 VMware/index.html","hash":"85e42cd76f72f41fc3ca07def462ee5150a008cb","modified":1696496713174},{"_id":"public/2023/09/30/DS_Lecture2 GFS/index.html","hash":"06085f532be19ce493062cf75b37839304039902","modified":1696496713174},{"_id":"public/2023/09/30/多状态DP/index.html","hash":"1f984d42650336e7c8cc2e0e78d1df1a83d86860","modified":1696496713174},{"_id":"public/2023/09/17/DS_Lecture1 mapreduce/index.html","hash":"d2fe39d48fd962a53ad8845ae6831d0531f7aa21","modified":1696496713174},{"_id":"public/2023/09/17/算法：单调队列/index.html","hash":"90fe1258cc6ebc410f9e0658f12a96e07d9606ad","modified":1696496713174},{"_id":"public/index.html","hash":"81262f9cfe41971567ea8d07597de8f5134a0f1d","modified":1696756958630},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1696496713174},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1696496713174},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1696496713174},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1696496713174},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1696496713174},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1696496713174},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1696496713174},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1696496713174},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1696496713174},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1696496713174},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1696496713174},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1696496713174},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1696496713174},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1696496713174},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1696496713174},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1696496713174},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1696496713174},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1696496713174},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1696496713174},{"_id":"public/css/main.css","hash":"1bfd9add1b53c7e3beba68f7f16ba0307c345007","modified":1696496713174},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1696496713174},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1696496713174},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1696496713174},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1696496713174},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1696496713174},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1696496713174},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1696496713174},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1696496713174},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1696496713174}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2023-09-30T07:10:17.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-09-30 15:10:17\n---\n","updated":"2023-09-30T07:10:17.346Z","path":"about/index.html","comments":1,"layout":"page","_id":"clncyc9yz00000wt66iz7cszy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2023-09-30T07:10:09.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-09-30 15:10:09\ntype: \"tags\"\n---\n","updated":"2023-09-30T07:16:12.606Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clncyc9z800020wt6dj5y3kid","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"分布式系统 容错VMware FT","date":"2023-10-02T16:26:51.000Z","_content":"VMware 的容错系统，走指令复制的路子\n<!-- more -->\n# 论文阅读\n本质上就是VMware的老本行，用VMM消除指令执行的不确定性，并通过传输指令的方式对系统进行复制\n## 主备份容错\n主备份服务器保持一致有两种方式：\n1. **状态转移**：将primary的所有状态发送给backup，缺点是传输数据量大。\n2. **备份状态机**：将primary的所有操作给backup一份，让backup称为primary的状态，传输数据量小。\n\n## VMware\n两个虚拟机分别是primary和backup，部署在不同机器上，共享磁盘。\n虚拟机和物理机之间有一层虚拟机管理程序（VMM）hypervisor，VMM对硬件的模拟和控制可以将不确定的操作确定化，保证后续的replay。\nprimary和backup之间通过**日志**来实现备份状态机同步。VMM将primary的所有操作确定化为一条x86 CPU指令，并写出日志，通过logging channel传输到backup的log cache上。\n## logging buffer和channel\nprimary和backup的状态备份通过**primary写出日志，backup读取日志**的方式进行。这个地方的写出、读取并不涉及磁盘，而是在内存中进行的，即logging buffer。\n两个logging buffer之间的通信通过logging channel进行。\n需要保证两者的logging buffer处于平衡状态，如果backup 的replay太慢，1.primary的logging buffer会爆，2.积存太多日志，primary失效后，需要等待backup较长时间执行replay操作。从外部看，系统响应时间较长。\n## FT Protocol\nlogging channel的协议\n### 基本要求\n当primary失效时，backup之后向client发送的所有output要与primary一致\n### Output Rule\n为了避免primary在output中断的时候故障，backup没有接收到primary的状态\n1. primary 在进行output之前，都把output相关信息发一份给backup，收到backup的ack以后才真正执行output操作\n2. primary等待backup的ack期间也执行后续操作，只是推迟output而已\n\n注：该协议无法保证重复输出，依赖于其他设施保证（如TCP检测重复数据包）\n## 故障监测和响应\n### 故障检测\nprimary和backup之间有三种信息可以用于进行故障检测，如果心跳和日志都超时了，就说明发生故障了\n1. primary和backup之间的心跳信息（UDP）\n2. logging channel的流量监测\n3. backup给primary的ack\n### 故障响应\nbackup检测到故障（长时间没有收到响应）后，并不能直接顶上primary的位置。因为直接顶上有脑裂的风险，同时存在两个primary对磁盘数据进行读写会造成数据损坏。\n所以两个虚拟机需要通过共享磁盘获取对方是否故障的信息。具体做法是通过test-and-set原子操作竞争磁盘，拿不到磁盘锁的就不是primary。\n若primary失效，那么backup顶上，并通过VMotion创建一个新backup，若backup失效，则创建一个新backup\n## VM-FT和GFS的区别\n本质上就是备份级别的问题，VM-FT是机器级的复制（low level 机器指令），GFS是应用级的复制（high level 数据库命令等）\n1. VM-FT备份**指令**，可以为**所有服务**提供容错服务，且**一致性严谨**\n2. GFS备份**数据**，**只针对数据存储**服务，备份策略更**高效**\n\n# 课程记录\n复制是容错的基本操作。但是复制并不能解决所有问题，主要解决的是fail-stop的错误，对软硬件的bug无能为力。\n## 复制的两种策略\n根据备份的内容和级别不同，可以分为以下两种备份策略\n1. state transfer状态转移：将内存、磁盘等内容拷贝给backup，简单粗暴\n2. replicated state machine复制状态机：将事件（指令）传递给backup，复杂\n\nreplicated state machine只是同步时成本低，但是当backup/primary失效时，仍是需要通过state transfer来创建新副本\n\n## VMware FT工作原理\n在两台物理机上部署VMM，VMM向两个异地虚拟机分配相同的配置（内存等），同一个LAN里还有一些客户端和共享磁盘（共享磁盘和客户端可以大致认定相同）\n由primary的VMM将外部输入转发给backup，backup的VMM知道自己是backup，所以会对backup虚拟机的输出进行丢包\n* 当primary发生故障时，backup的VMM会在一些防止split-brain的操作后充当primary，不再丢包，执行primary的转发功能，并控制生成backup\n* 当backup发生故障时，primary的VMM会控制生成新的backup，并转发数据包到新的backup上\n## 不确定事件\n不确定事件可以有以下几类\n1. 客户端输入：不可控\n2. 怪异指令：随机数、获取当前时间、获取计算机id\n3. 多CPU并发的指令执行顺序\n\n这些事件都要通过log channel发送到backup，老师猜测的日志内容应该包括\n1. 事件的指令序号\n2. 日志类型：数据包or怪异指令？\n3. 数据：数据包就是普通数据，怪异指令就是提供primary执行该指令后的系统状态，方便backup伪造该指令\n","source":"_posts/DS-Lecture3 VMware.md","raw":"---\ntitle: 分布式系统 容错VMware FT\ndate: 2023-10-03 00:26:51\ntags:\n    - mit 6.824\n    - 容错\n---\nVMware 的容错系统，走指令复制的路子\n<!-- more -->\n# 论文阅读\n本质上就是VMware的老本行，用VMM消除指令执行的不确定性，并通过传输指令的方式对系统进行复制\n## 主备份容错\n主备份服务器保持一致有两种方式：\n1. **状态转移**：将primary的所有状态发送给backup，缺点是传输数据量大。\n2. **备份状态机**：将primary的所有操作给backup一份，让backup称为primary的状态，传输数据量小。\n\n## VMware\n两个虚拟机分别是primary和backup，部署在不同机器上，共享磁盘。\n虚拟机和物理机之间有一层虚拟机管理程序（VMM）hypervisor，VMM对硬件的模拟和控制可以将不确定的操作确定化，保证后续的replay。\nprimary和backup之间通过**日志**来实现备份状态机同步。VMM将primary的所有操作确定化为一条x86 CPU指令，并写出日志，通过logging channel传输到backup的log cache上。\n## logging buffer和channel\nprimary和backup的状态备份通过**primary写出日志，backup读取日志**的方式进行。这个地方的写出、读取并不涉及磁盘，而是在内存中进行的，即logging buffer。\n两个logging buffer之间的通信通过logging channel进行。\n需要保证两者的logging buffer处于平衡状态，如果backup 的replay太慢，1.primary的logging buffer会爆，2.积存太多日志，primary失效后，需要等待backup较长时间执行replay操作。从外部看，系统响应时间较长。\n## FT Protocol\nlogging channel的协议\n### 基本要求\n当primary失效时，backup之后向client发送的所有output要与primary一致\n### Output Rule\n为了避免primary在output中断的时候故障，backup没有接收到primary的状态\n1. primary 在进行output之前，都把output相关信息发一份给backup，收到backup的ack以后才真正执行output操作\n2. primary等待backup的ack期间也执行后续操作，只是推迟output而已\n\n注：该协议无法保证重复输出，依赖于其他设施保证（如TCP检测重复数据包）\n## 故障监测和响应\n### 故障检测\nprimary和backup之间有三种信息可以用于进行故障检测，如果心跳和日志都超时了，就说明发生故障了\n1. primary和backup之间的心跳信息（UDP）\n2. logging channel的流量监测\n3. backup给primary的ack\n### 故障响应\nbackup检测到故障（长时间没有收到响应）后，并不能直接顶上primary的位置。因为直接顶上有脑裂的风险，同时存在两个primary对磁盘数据进行读写会造成数据损坏。\n所以两个虚拟机需要通过共享磁盘获取对方是否故障的信息。具体做法是通过test-and-set原子操作竞争磁盘，拿不到磁盘锁的就不是primary。\n若primary失效，那么backup顶上，并通过VMotion创建一个新backup，若backup失效，则创建一个新backup\n## VM-FT和GFS的区别\n本质上就是备份级别的问题，VM-FT是机器级的复制（low level 机器指令），GFS是应用级的复制（high level 数据库命令等）\n1. VM-FT备份**指令**，可以为**所有服务**提供容错服务，且**一致性严谨**\n2. GFS备份**数据**，**只针对数据存储**服务，备份策略更**高效**\n\n# 课程记录\n复制是容错的基本操作。但是复制并不能解决所有问题，主要解决的是fail-stop的错误，对软硬件的bug无能为力。\n## 复制的两种策略\n根据备份的内容和级别不同，可以分为以下两种备份策略\n1. state transfer状态转移：将内存、磁盘等内容拷贝给backup，简单粗暴\n2. replicated state machine复制状态机：将事件（指令）传递给backup，复杂\n\nreplicated state machine只是同步时成本低，但是当backup/primary失效时，仍是需要通过state transfer来创建新副本\n\n## VMware FT工作原理\n在两台物理机上部署VMM，VMM向两个异地虚拟机分配相同的配置（内存等），同一个LAN里还有一些客户端和共享磁盘（共享磁盘和客户端可以大致认定相同）\n由primary的VMM将外部输入转发给backup，backup的VMM知道自己是backup，所以会对backup虚拟机的输出进行丢包\n* 当primary发生故障时，backup的VMM会在一些防止split-brain的操作后充当primary，不再丢包，执行primary的转发功能，并控制生成backup\n* 当backup发生故障时，primary的VMM会控制生成新的backup，并转发数据包到新的backup上\n## 不确定事件\n不确定事件可以有以下几类\n1. 客户端输入：不可控\n2. 怪异指令：随机数、获取当前时间、获取计算机id\n3. 多CPU并发的指令执行顺序\n\n这些事件都要通过log channel发送到backup，老师猜测的日志内容应该包括\n1. 事件的指令序号\n2. 日志类型：数据包or怪异指令？\n3. 数据：数据包就是普通数据，怪异指令就是提供primary执行该指令后的系统状态，方便backup伪造该指令\n","slug":"DS-Lecture3 VMware","published":1,"updated":"2023-10-05T07:05:00.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clncyc9z400010wt6ghnb0ifz","content":"<p>VMware 的容错系统，走指令复制的路子</p>\n<span id=\"more\"></span>\n<h1 id=\"论文阅读\"><a href=\"#论文阅读\" class=\"headerlink\" title=\"论文阅读\"></a>论文阅读</h1><p>本质上就是VMware的老本行，用VMM消除指令执行的不确定性，并通过传输指令的方式对系统进行复制</p>\n<h2 id=\"主备份容错\"><a href=\"#主备份容错\" class=\"headerlink\" title=\"主备份容错\"></a>主备份容错</h2><p>主备份服务器保持一致有两种方式：</p>\n<ol>\n<li><strong>状态转移</strong>：将primary的所有状态发送给backup，缺点是传输数据量大。</li>\n<li><strong>备份状态机</strong>：将primary的所有操作给backup一份，让backup称为primary的状态，传输数据量小。</li>\n</ol>\n<h2 id=\"VMware\"><a href=\"#VMware\" class=\"headerlink\" title=\"VMware\"></a>VMware</h2><p>两个虚拟机分别是primary和backup，部署在不同机器上，共享磁盘。<br>虚拟机和物理机之间有一层虚拟机管理程序（VMM）hypervisor，VMM对硬件的模拟和控制可以将不确定的操作确定化，保证后续的replay。<br>primary和backup之间通过<strong>日志</strong>来实现备份状态机同步。VMM将primary的所有操作确定化为一条x86 CPU指令，并写出日志，通过logging channel传输到backup的log cache上。</p>\n<h2 id=\"logging-buffer和channel\"><a href=\"#logging-buffer和channel\" class=\"headerlink\" title=\"logging buffer和channel\"></a>logging buffer和channel</h2><p>primary和backup的状态备份通过<strong>primary写出日志，backup读取日志</strong>的方式进行。这个地方的写出、读取并不涉及磁盘，而是在内存中进行的，即logging buffer。<br>两个logging buffer之间的通信通过logging channel进行。<br>需要保证两者的logging buffer处于平衡状态，如果backup 的replay太慢，1.primary的logging buffer会爆，2.积存太多日志，primary失效后，需要等待backup较长时间执行replay操作。从外部看，系统响应时间较长。</p>\n<h2 id=\"FT-Protocol\"><a href=\"#FT-Protocol\" class=\"headerlink\" title=\"FT Protocol\"></a>FT Protocol</h2><p>logging channel的协议</p>\n<h3 id=\"基本要求\"><a href=\"#基本要求\" class=\"headerlink\" title=\"基本要求\"></a>基本要求</h3><p>当primary失效时，backup之后向client发送的所有output要与primary一致</p>\n<h3 id=\"Output-Rule\"><a href=\"#Output-Rule\" class=\"headerlink\" title=\"Output Rule\"></a>Output Rule</h3><p>为了避免primary在output中断的时候故障，backup没有接收到primary的状态</p>\n<ol>\n<li>primary 在进行output之前，都把output相关信息发一份给backup，收到backup的ack以后才真正执行output操作</li>\n<li>primary等待backup的ack期间也执行后续操作，只是推迟output而已</li>\n</ol>\n<p>注：该协议无法保证重复输出，依赖于其他设施保证（如TCP检测重复数据包）</p>\n<h2 id=\"故障监测和响应\"><a href=\"#故障监测和响应\" class=\"headerlink\" title=\"故障监测和响应\"></a>故障监测和响应</h2><h3 id=\"故障检测\"><a href=\"#故障检测\" class=\"headerlink\" title=\"故障检测\"></a>故障检测</h3><p>primary和backup之间有三种信息可以用于进行故障检测，如果心跳和日志都超时了，就说明发生故障了</p>\n<ol>\n<li>primary和backup之间的心跳信息（UDP）</li>\n<li>logging channel的流量监测</li>\n<li>backup给primary的ack</li>\n</ol>\n<h3 id=\"故障响应\"><a href=\"#故障响应\" class=\"headerlink\" title=\"故障响应\"></a>故障响应</h3><p>backup检测到故障（长时间没有收到响应）后，并不能直接顶上primary的位置。因为直接顶上有脑裂的风险，同时存在两个primary对磁盘数据进行读写会造成数据损坏。<br>所以两个虚拟机需要通过共享磁盘获取对方是否故障的信息。具体做法是通过test-and-set原子操作竞争磁盘，拿不到磁盘锁的就不是primary。<br>若primary失效，那么backup顶上，并通过VMotion创建一个新backup，若backup失效，则创建一个新backup</p>\n<h2 id=\"VM-FT和GFS的区别\"><a href=\"#VM-FT和GFS的区别\" class=\"headerlink\" title=\"VM-FT和GFS的区别\"></a>VM-FT和GFS的区别</h2><p>本质上就是备份级别的问题，VM-FT是机器级的复制（low level 机器指令），GFS是应用级的复制（high level 数据库命令等）</p>\n<ol>\n<li>VM-FT备份<strong>指令</strong>，可以为<strong>所有服务</strong>提供容错服务，且<strong>一致性严谨</strong></li>\n<li>GFS备份<strong>数据</strong>，<strong>只针对数据存储</strong>服务，备份策略更<strong>高效</strong></li>\n</ol>\n<h1 id=\"课程记录\"><a href=\"#课程记录\" class=\"headerlink\" title=\"课程记录\"></a>课程记录</h1><p>复制是容错的基本操作。但是复制并不能解决所有问题，主要解决的是fail-stop的错误，对软硬件的bug无能为力。</p>\n<h2 id=\"复制的两种策略\"><a href=\"#复制的两种策略\" class=\"headerlink\" title=\"复制的两种策略\"></a>复制的两种策略</h2><p>根据备份的内容和级别不同，可以分为以下两种备份策略</p>\n<ol>\n<li>state transfer状态转移：将内存、磁盘等内容拷贝给backup，简单粗暴</li>\n<li>replicated state machine复制状态机：将事件（指令）传递给backup，复杂</li>\n</ol>\n<p>replicated state machine只是同步时成本低，但是当backup&#x2F;primary失效时，仍是需要通过state transfer来创建新副本</p>\n<h2 id=\"VMware-FT工作原理\"><a href=\"#VMware-FT工作原理\" class=\"headerlink\" title=\"VMware FT工作原理\"></a>VMware FT工作原理</h2><p>在两台物理机上部署VMM，VMM向两个异地虚拟机分配相同的配置（内存等），同一个LAN里还有一些客户端和共享磁盘（共享磁盘和客户端可以大致认定相同）<br>由primary的VMM将外部输入转发给backup，backup的VMM知道自己是backup，所以会对backup虚拟机的输出进行丢包</p>\n<ul>\n<li>当primary发生故障时，backup的VMM会在一些防止split-brain的操作后充当primary，不再丢包，执行primary的转发功能，并控制生成backup</li>\n<li>当backup发生故障时，primary的VMM会控制生成新的backup，并转发数据包到新的backup上</li>\n</ul>\n<h2 id=\"不确定事件\"><a href=\"#不确定事件\" class=\"headerlink\" title=\"不确定事件\"></a>不确定事件</h2><p>不确定事件可以有以下几类</p>\n<ol>\n<li>客户端输入：不可控</li>\n<li>怪异指令：随机数、获取当前时间、获取计算机id</li>\n<li>多CPU并发的指令执行顺序</li>\n</ol>\n<p>这些事件都要通过log channel发送到backup，老师猜测的日志内容应该包括</p>\n<ol>\n<li>事件的指令序号</li>\n<li>日志类型：数据包or怪异指令？</li>\n<li>数据：数据包就是普通数据，怪异指令就是提供primary执行该指令后的系统状态，方便backup伪造该指令</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>VMware 的容错系统，走指令复制的路子</p>","more":"<h1 id=\"论文阅读\"><a href=\"#论文阅读\" class=\"headerlink\" title=\"论文阅读\"></a>论文阅读</h1><p>本质上就是VMware的老本行，用VMM消除指令执行的不确定性，并通过传输指令的方式对系统进行复制</p>\n<h2 id=\"主备份容错\"><a href=\"#主备份容错\" class=\"headerlink\" title=\"主备份容错\"></a>主备份容错</h2><p>主备份服务器保持一致有两种方式：</p>\n<ol>\n<li><strong>状态转移</strong>：将primary的所有状态发送给backup，缺点是传输数据量大。</li>\n<li><strong>备份状态机</strong>：将primary的所有操作给backup一份，让backup称为primary的状态，传输数据量小。</li>\n</ol>\n<h2 id=\"VMware\"><a href=\"#VMware\" class=\"headerlink\" title=\"VMware\"></a>VMware</h2><p>两个虚拟机分别是primary和backup，部署在不同机器上，共享磁盘。<br>虚拟机和物理机之间有一层虚拟机管理程序（VMM）hypervisor，VMM对硬件的模拟和控制可以将不确定的操作确定化，保证后续的replay。<br>primary和backup之间通过<strong>日志</strong>来实现备份状态机同步。VMM将primary的所有操作确定化为一条x86 CPU指令，并写出日志，通过logging channel传输到backup的log cache上。</p>\n<h2 id=\"logging-buffer和channel\"><a href=\"#logging-buffer和channel\" class=\"headerlink\" title=\"logging buffer和channel\"></a>logging buffer和channel</h2><p>primary和backup的状态备份通过<strong>primary写出日志，backup读取日志</strong>的方式进行。这个地方的写出、读取并不涉及磁盘，而是在内存中进行的，即logging buffer。<br>两个logging buffer之间的通信通过logging channel进行。<br>需要保证两者的logging buffer处于平衡状态，如果backup 的replay太慢，1.primary的logging buffer会爆，2.积存太多日志，primary失效后，需要等待backup较长时间执行replay操作。从外部看，系统响应时间较长。</p>\n<h2 id=\"FT-Protocol\"><a href=\"#FT-Protocol\" class=\"headerlink\" title=\"FT Protocol\"></a>FT Protocol</h2><p>logging channel的协议</p>\n<h3 id=\"基本要求\"><a href=\"#基本要求\" class=\"headerlink\" title=\"基本要求\"></a>基本要求</h3><p>当primary失效时，backup之后向client发送的所有output要与primary一致</p>\n<h3 id=\"Output-Rule\"><a href=\"#Output-Rule\" class=\"headerlink\" title=\"Output Rule\"></a>Output Rule</h3><p>为了避免primary在output中断的时候故障，backup没有接收到primary的状态</p>\n<ol>\n<li>primary 在进行output之前，都把output相关信息发一份给backup，收到backup的ack以后才真正执行output操作</li>\n<li>primary等待backup的ack期间也执行后续操作，只是推迟output而已</li>\n</ol>\n<p>注：该协议无法保证重复输出，依赖于其他设施保证（如TCP检测重复数据包）</p>\n<h2 id=\"故障监测和响应\"><a href=\"#故障监测和响应\" class=\"headerlink\" title=\"故障监测和响应\"></a>故障监测和响应</h2><h3 id=\"故障检测\"><a href=\"#故障检测\" class=\"headerlink\" title=\"故障检测\"></a>故障检测</h3><p>primary和backup之间有三种信息可以用于进行故障检测，如果心跳和日志都超时了，就说明发生故障了</p>\n<ol>\n<li>primary和backup之间的心跳信息（UDP）</li>\n<li>logging channel的流量监测</li>\n<li>backup给primary的ack</li>\n</ol>\n<h3 id=\"故障响应\"><a href=\"#故障响应\" class=\"headerlink\" title=\"故障响应\"></a>故障响应</h3><p>backup检测到故障（长时间没有收到响应）后，并不能直接顶上primary的位置。因为直接顶上有脑裂的风险，同时存在两个primary对磁盘数据进行读写会造成数据损坏。<br>所以两个虚拟机需要通过共享磁盘获取对方是否故障的信息。具体做法是通过test-and-set原子操作竞争磁盘，拿不到磁盘锁的就不是primary。<br>若primary失效，那么backup顶上，并通过VMotion创建一个新backup，若backup失效，则创建一个新backup</p>\n<h2 id=\"VM-FT和GFS的区别\"><a href=\"#VM-FT和GFS的区别\" class=\"headerlink\" title=\"VM-FT和GFS的区别\"></a>VM-FT和GFS的区别</h2><p>本质上就是备份级别的问题，VM-FT是机器级的复制（low level 机器指令），GFS是应用级的复制（high level 数据库命令等）</p>\n<ol>\n<li>VM-FT备份<strong>指令</strong>，可以为<strong>所有服务</strong>提供容错服务，且<strong>一致性严谨</strong></li>\n<li>GFS备份<strong>数据</strong>，<strong>只针对数据存储</strong>服务，备份策略更<strong>高效</strong></li>\n</ol>\n<h1 id=\"课程记录\"><a href=\"#课程记录\" class=\"headerlink\" title=\"课程记录\"></a>课程记录</h1><p>复制是容错的基本操作。但是复制并不能解决所有问题，主要解决的是fail-stop的错误，对软硬件的bug无能为力。</p>\n<h2 id=\"复制的两种策略\"><a href=\"#复制的两种策略\" class=\"headerlink\" title=\"复制的两种策略\"></a>复制的两种策略</h2><p>根据备份的内容和级别不同，可以分为以下两种备份策略</p>\n<ol>\n<li>state transfer状态转移：将内存、磁盘等内容拷贝给backup，简单粗暴</li>\n<li>replicated state machine复制状态机：将事件（指令）传递给backup，复杂</li>\n</ol>\n<p>replicated state machine只是同步时成本低，但是当backup&#x2F;primary失效时，仍是需要通过state transfer来创建新副本</p>\n<h2 id=\"VMware-FT工作原理\"><a href=\"#VMware-FT工作原理\" class=\"headerlink\" title=\"VMware FT工作原理\"></a>VMware FT工作原理</h2><p>在两台物理机上部署VMM，VMM向两个异地虚拟机分配相同的配置（内存等），同一个LAN里还有一些客户端和共享磁盘（共享磁盘和客户端可以大致认定相同）<br>由primary的VMM将外部输入转发给backup，backup的VMM知道自己是backup，所以会对backup虚拟机的输出进行丢包</p>\n<ul>\n<li>当primary发生故障时，backup的VMM会在一些防止split-brain的操作后充当primary，不再丢包，执行primary的转发功能，并控制生成backup</li>\n<li>当backup发生故障时，primary的VMM会控制生成新的backup，并转发数据包到新的backup上</li>\n</ul>\n<h2 id=\"不确定事件\"><a href=\"#不确定事件\" class=\"headerlink\" title=\"不确定事件\"></a>不确定事件</h2><p>不确定事件可以有以下几类</p>\n<ol>\n<li>客户端输入：不可控</li>\n<li>怪异指令：随机数、获取当前时间、获取计算机id</li>\n<li>多CPU并发的指令执行顺序</li>\n</ol>\n<p>这些事件都要通过log channel发送到backup，老师猜测的日志内容应该包括</p>\n<ol>\n<li>事件的指令序号</li>\n<li>日志类型：数据包or怪异指令？</li>\n<li>数据：数据包就是普通数据，怪异指令就是提供primary执行该指令后的系统状态，方便backup伪造该指令</li>\n</ol>"},{"title":"保证不重复的dp","date":"2023-10-04T01:43:30.000Z","_content":"一道通过dp遍历顺序保证不重复的题目，咋一看很简单，细看有点难\n<!-- more -->\n# 题目\n(leetcode 518. 零钱兑换 II)[https://leetcode.cn/problems/coin-change-ii/solutions/821278/ling-qian-dui-huan-ii-by-leetcode-soluti-f7uh/]\n# 题解\n这个题很容易想到dp，但是普通的dp一般是外层遍历金额，内层遍历coins。这么做的问题是会重复计数，例如：coins=[1,2] amount = 3，当计算3时，会算到3种[1+1+1,2+1,1+2]，但是后两种是重复的。\n为了保证计数不重复，外层遍历的是coins，内层才是金额，不断的加加加。\n不重复计数原因：当前的coin一定是之前没算过的\n# 代码\n```c++\nclass Solution {\npublic:  \n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount + 1, 0);\n        dp[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; ++i) {\n                dp[i]+=dp[i - coin];\n            }\n        }\n        return dp[amount];\n    }\n};\n```","source":"_posts/保证不重复的dp.md","raw":"---\ntitle: 保证不重复的dp\ndate: 2023-10-04 09:43:30\ntags:\n    - 算法\n    - DP\n---\n一道通过dp遍历顺序保证不重复的题目，咋一看很简单，细看有点难\n<!-- more -->\n# 题目\n(leetcode 518. 零钱兑换 II)[https://leetcode.cn/problems/coin-change-ii/solutions/821278/ling-qian-dui-huan-ii-by-leetcode-soluti-f7uh/]\n# 题解\n这个题很容易想到dp，但是普通的dp一般是外层遍历金额，内层遍历coins。这么做的问题是会重复计数，例如：coins=[1,2] amount = 3，当计算3时，会算到3种[1+1+1,2+1,1+2]，但是后两种是重复的。\n为了保证计数不重复，外层遍历的是coins，内层才是金额，不断的加加加。\n不重复计数原因：当前的coin一定是之前没算过的\n# 代码\n```c++\nclass Solution {\npublic:  \n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount + 1, 0);\n        dp[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; ++i) {\n                dp[i]+=dp[i - coin];\n            }\n        }\n        return dp[amount];\n    }\n};\n```","slug":"保证不重复的dp","published":1,"updated":"2023-10-04T02:36:27.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clncyc9z900030wt6av472ca3","content":"<p>一道通过dp遍历顺序保证不重复的题目，咋一看很简单，细看有点难</p>\n<span id=\"more\"></span>\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>(leetcode 518. 零钱兑换 II)[<a href=\"https://leetcode.cn/problems/coin-change-ii/solutions/821278/ling-qian-dui-huan-ii-by-leetcode-soluti-f7uh/]\">https://leetcode.cn/problems/coin-change-ii/solutions/821278/ling-qian-dui-huan-ii-by-leetcode-soluti-f7uh/]</a></p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><p>这个题很容易想到dp，但是普通的dp一般是外层遍历金额，内层遍历coins。这么做的问题是会重复计数，例如：coins&#x3D;[1,2] amount &#x3D; 3，当计算3时，会算到3种[1+1+1,2+1,1+2]，但是后两种是重复的。<br>为了保证计数不重复，外层遍历的是coins，内层才是金额，不断的加加加。<br>不重复计数原因：当前的coin一定是之前没算过的</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"type\">int</span> amount, vector&lt;<span class=\"type\">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(amount + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> coin : coins) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = coin; i &lt;= amount; ++i) &#123;</span><br><span class=\"line\">                dp[i]+=dp[i - coin];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一道通过dp遍历顺序保证不重复的题目，咋一看很简单，细看有点难</p>","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p>(leetcode 518. 零钱兑换 II)[<a href=\"https://leetcode.cn/problems/coin-change-ii/solutions/821278/ling-qian-dui-huan-ii-by-leetcode-soluti-f7uh/]\">https://leetcode.cn/problems/coin-change-ii/solutions/821278/ling-qian-dui-huan-ii-by-leetcode-soluti-f7uh/]</a></p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><p>这个题很容易想到dp，但是普通的dp一般是外层遍历金额，内层遍历coins。这么做的问题是会重复计数，例如：coins&#x3D;[1,2] amount &#x3D; 3，当计算3时，会算到3种[1+1+1,2+1,1+2]，但是后两种是重复的。<br>为了保证计数不重复，外层遍历的是coins，内层才是金额，不断的加加加。<br>不重复计数原因：当前的coin一定是之前没算过的</p>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">change</span><span class=\"params\">(<span class=\"type\">int</span> amount, vector&lt;<span class=\"type\">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(amount + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> coin : coins) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = coin; i &lt;= amount; ++i) &#123;</span><br><span class=\"line\">                dp[i]+=dp[i - coin];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"分布式系统 Raft","date":"2023-10-05T07:03:37.000Z","_content":"分布式协同算法 Raft\n\n<!-- more -->\n\n# 论文阅读\n\n以前的算法存在两个问题，1. 不容易理解2.对于现实问题没有好的基础，所以raft设计的目标就是好理解。为此，Raft使用了两个方法，1.问题分解2.简化系统状态\nraft算法核心是leader，leader的产生简化了系统，因为leader可以决定新日志条目存放的地方，数据流也只从leader流向其他server。系统最简单来说就是两步\n\n1. 选举leader\n2. leader管理复制日志\n\n具体而言，Raft将问题分解为以下几个子问题\n\n1. **leader选举**\n2. **日志复制**：leader管理\n3. **安全**：保证系统属性安全\n\n## Raft基础\n\n### 状态state\n\n系统中的server有三个状态 `leader`、`follower`、`candidate`。\n`follower`是完全被动的接收来自其他两种server的指令；`leader`会处理所有来自client的请求，其他server也将请求转发给 `leader`；`candidate`则是选举过程中的中间状态。\n\n```mermaid\ngraph TD\n    A[Follower] -->|开始选举| B(Candidate)\n    B --> |重新选举|B\n    B --> |获得大多数选票| C(Leader)\n    C --> |其他server有更大的term编号| A\n    B --> |当前系统有leader了or其他server有更大的term编号| A\n```\n\n### 时间片term\n\n系统的term（时间片）是任意(随机)长度的，每一个term都由选举开始，如果选举失败，该term立即终止，马上进入下一个term。Raft始终保证系统中有且仅有一个leader。\n系统中的server保存了当前的term编号，如果server发现自己的term编号比其他server小，则自增到新的term编号，如果leader或candidate发现自己的编号过时了，则马上降级到follower\n如果server收到了term编号不对的请求，将该请求丢弃。\n\n### 通信 RPC\n\n系统中需要三条RPC通信路径\n\n1. **RequestVote RPCs**：在选举过程中，由候选者初始化\n2. **AppendEntries RPCs**：由leader初始化，在系统运行时提供日志条目复制和心跳功能\n3. **TransferSnapshot RPCs**：传递server快照的RPCs\n\n## Raft性质\n\nRaft算法运行中全程保证这些性质成立\n\n1. **选举安全**：一个term中至多存在一个leader\n2. **leader仅追加log**：leader的log不会被其他server覆写\n3. **log匹配**：两个拥有相同index和term的log必然完全相同，且前序log也相同\n4. **leader完整性**：committed的log entry一定会在后续的leader log中出现\n5. **状态机安全性**：\n\n## 选举\n\nserver以follower身份启动，leader会定时发心跳信息（无日志信息的appendEntries）给follower维护自己的leader地位。当follower超时未收到心跳信息时则开启选举。\n选举过程是follower将term编号自增并进入candidate状态，然后给自己投票，并向其他server并行发出RequestVote RPCs请求票。\n每个server在一个term里至多给一个server投票，投票遵循先到先得原则。\n\n### 选举结果\n\ncandidates状态的结果有三种：\n\n1. 获取大部分选票，赢得选举->leader 开始发心跳信息维护自己的leader地位\n2. 收到了其他server的RequestVote RPCs，若其term编号大于等于自己，则认定其为合法leader->follower （否则自己仍为candidate）\n3. 当多个server同时进入candidate状态并发送RequestVote RPCs，没人赢得选举->candidate 重启选举流程\n\n### 随机超时机制\n\n为了保证系统尽量少进入第三个状态，即无人赢得选举，不停地选举，Raft采用随机的超时时限（150-300ms之间）。这样可以保证在在某一个时刻，只有一个server发现超时，并赢得选举。\n每一个candidate在term开始时重新获取一个随机超时时限，\n\n## 日志复制\n\n当client发送命令时，系统中会按顺序发生如下事件：\n\n1. leader追加一个新的log entry，也就是这条命令\n2. 发布AppendEntries RPCs给其他server\n3. 当这个entry完成安全的复制后，leader会执行该命令\n4. 返回执行结果给client\n\n### 日志内容\n\n日志将包含两个部分：\n\n1. 状态机命令\n2. term编号：标记这条命令产生的时期\n\n### commited entry\n\n* 当entry被大多数（为什么是大多数？）server复制时，该log entry会变成commited状态。Raft将会保证系统中commited的entry被持久化以及被所有server执行。\n* 当一条log entry是commited时，这条日志之前的所有entries都会被commit，不论任何leader产生的。\n* leader会追踪将要commit的最早entry，并用其发送appendEntries RPCs\n* 当follower得知entry被commit以后，就会执行该entry包含的命令\n\n### 运行时日志一致性保证\n\n日志有两个属性\n\n* index和term相同的log，命令必然相同\n* index和term相同的log，前置log必然相同\n\n发送AppendEntries RPC时，leader会将前一个log的index和term也附上，如果follower没找到前一个log，那也不读入当前log\n\n### leader对日志一致性保证\n\n正常运行时，leader和多个follower的日志将会保持一致，当leader挂掉重新选举时，可能会导致日志出现不一致的现象，此时leader将自己的log强制复制给follower。leader会为**每个follower**更新nextIndex，用来指示向特定follower发送的下一条log entry。具体做法是：\n\n1. **初始化**：将nextIndex初始化为leader的最后一条log entry的下一条\n2. **试错**：给follower发送下一条的AppendEntries，如果失败，nextIndex--（也可以通过返回entries，让leader直接查找nextIndex）\n3. **结果**：当AppendEntries成功时，正确的nextIndex就找到了\n4. **更新**：将leader后续的log entries通过AppendEntries发送给follower，覆盖掉不一致的日志\n\n通过这些措施，leader在选举成功后，就会让整个系统里的follower逐渐收敛到自己的日志中来。同时，leader是不会删除（覆盖）自己的日志，只会覆盖掉follower的日志\n\n## 安全性\n\n### 选举限制\n为了简化算法，只允许log entries从leader流向follower，Raft保证leader会包含已经被提交的所有log entries。\nRaft使用voting的方法来保证leader拥有所有的log entries。candidate发送带有自己所有log entries的RequestVote RPC给其他server，如果其他server发现candidate的log entries没有自己新，则否决该candidate。\n判断log entries新旧方法：比较最后一个log entry的index和term，term编号更大的更新，如果term编号一样，则index更大的更新\n\n### 提交限制\nleader只能提交当前term中的log entry，相当于间接提交了其他term的log entry\n\n# 课堂记录\n## 脑裂\n之前提到的容错系统mapreduce、GFS、Vmware FT，都是单主节点。单主节点本身就是一个单点障碍，一旦出错就比较麻烦。\n主节点出错的一个方式是split brain(脑裂)，也就是说系统中存在多个主节点，可能会导致系统中出现各种矛盾和错误\n解决方案包括两种\n1. 构建完美的网络：高成本\n2. 人工解决问题：慢","source":"_posts/DS-Lecture4 Raft.md","raw":"---\ntitle: 分布式系统 Raft\ndate: 2023-10-05 15:03:37\ntags:\n    - mit 6.824\n    - 容错\n    - Raft\n---\n分布式协同算法 Raft\n\n<!-- more -->\n\n# 论文阅读\n\n以前的算法存在两个问题，1. 不容易理解2.对于现实问题没有好的基础，所以raft设计的目标就是好理解。为此，Raft使用了两个方法，1.问题分解2.简化系统状态\nraft算法核心是leader，leader的产生简化了系统，因为leader可以决定新日志条目存放的地方，数据流也只从leader流向其他server。系统最简单来说就是两步\n\n1. 选举leader\n2. leader管理复制日志\n\n具体而言，Raft将问题分解为以下几个子问题\n\n1. **leader选举**\n2. **日志复制**：leader管理\n3. **安全**：保证系统属性安全\n\n## Raft基础\n\n### 状态state\n\n系统中的server有三个状态 `leader`、`follower`、`candidate`。\n`follower`是完全被动的接收来自其他两种server的指令；`leader`会处理所有来自client的请求，其他server也将请求转发给 `leader`；`candidate`则是选举过程中的中间状态。\n\n```mermaid\ngraph TD\n    A[Follower] -->|开始选举| B(Candidate)\n    B --> |重新选举|B\n    B --> |获得大多数选票| C(Leader)\n    C --> |其他server有更大的term编号| A\n    B --> |当前系统有leader了or其他server有更大的term编号| A\n```\n\n### 时间片term\n\n系统的term（时间片）是任意(随机)长度的，每一个term都由选举开始，如果选举失败，该term立即终止，马上进入下一个term。Raft始终保证系统中有且仅有一个leader。\n系统中的server保存了当前的term编号，如果server发现自己的term编号比其他server小，则自增到新的term编号，如果leader或candidate发现自己的编号过时了，则马上降级到follower\n如果server收到了term编号不对的请求，将该请求丢弃。\n\n### 通信 RPC\n\n系统中需要三条RPC通信路径\n\n1. **RequestVote RPCs**：在选举过程中，由候选者初始化\n2. **AppendEntries RPCs**：由leader初始化，在系统运行时提供日志条目复制和心跳功能\n3. **TransferSnapshot RPCs**：传递server快照的RPCs\n\n## Raft性质\n\nRaft算法运行中全程保证这些性质成立\n\n1. **选举安全**：一个term中至多存在一个leader\n2. **leader仅追加log**：leader的log不会被其他server覆写\n3. **log匹配**：两个拥有相同index和term的log必然完全相同，且前序log也相同\n4. **leader完整性**：committed的log entry一定会在后续的leader log中出现\n5. **状态机安全性**：\n\n## 选举\n\nserver以follower身份启动，leader会定时发心跳信息（无日志信息的appendEntries）给follower维护自己的leader地位。当follower超时未收到心跳信息时则开启选举。\n选举过程是follower将term编号自增并进入candidate状态，然后给自己投票，并向其他server并行发出RequestVote RPCs请求票。\n每个server在一个term里至多给一个server投票，投票遵循先到先得原则。\n\n### 选举结果\n\ncandidates状态的结果有三种：\n\n1. 获取大部分选票，赢得选举->leader 开始发心跳信息维护自己的leader地位\n2. 收到了其他server的RequestVote RPCs，若其term编号大于等于自己，则认定其为合法leader->follower （否则自己仍为candidate）\n3. 当多个server同时进入candidate状态并发送RequestVote RPCs，没人赢得选举->candidate 重启选举流程\n\n### 随机超时机制\n\n为了保证系统尽量少进入第三个状态，即无人赢得选举，不停地选举，Raft采用随机的超时时限（150-300ms之间）。这样可以保证在在某一个时刻，只有一个server发现超时，并赢得选举。\n每一个candidate在term开始时重新获取一个随机超时时限，\n\n## 日志复制\n\n当client发送命令时，系统中会按顺序发生如下事件：\n\n1. leader追加一个新的log entry，也就是这条命令\n2. 发布AppendEntries RPCs给其他server\n3. 当这个entry完成安全的复制后，leader会执行该命令\n4. 返回执行结果给client\n\n### 日志内容\n\n日志将包含两个部分：\n\n1. 状态机命令\n2. term编号：标记这条命令产生的时期\n\n### commited entry\n\n* 当entry被大多数（为什么是大多数？）server复制时，该log entry会变成commited状态。Raft将会保证系统中commited的entry被持久化以及被所有server执行。\n* 当一条log entry是commited时，这条日志之前的所有entries都会被commit，不论任何leader产生的。\n* leader会追踪将要commit的最早entry，并用其发送appendEntries RPCs\n* 当follower得知entry被commit以后，就会执行该entry包含的命令\n\n### 运行时日志一致性保证\n\n日志有两个属性\n\n* index和term相同的log，命令必然相同\n* index和term相同的log，前置log必然相同\n\n发送AppendEntries RPC时，leader会将前一个log的index和term也附上，如果follower没找到前一个log，那也不读入当前log\n\n### leader对日志一致性保证\n\n正常运行时，leader和多个follower的日志将会保持一致，当leader挂掉重新选举时，可能会导致日志出现不一致的现象，此时leader将自己的log强制复制给follower。leader会为**每个follower**更新nextIndex，用来指示向特定follower发送的下一条log entry。具体做法是：\n\n1. **初始化**：将nextIndex初始化为leader的最后一条log entry的下一条\n2. **试错**：给follower发送下一条的AppendEntries，如果失败，nextIndex--（也可以通过返回entries，让leader直接查找nextIndex）\n3. **结果**：当AppendEntries成功时，正确的nextIndex就找到了\n4. **更新**：将leader后续的log entries通过AppendEntries发送给follower，覆盖掉不一致的日志\n\n通过这些措施，leader在选举成功后，就会让整个系统里的follower逐渐收敛到自己的日志中来。同时，leader是不会删除（覆盖）自己的日志，只会覆盖掉follower的日志\n\n## 安全性\n\n### 选举限制\n为了简化算法，只允许log entries从leader流向follower，Raft保证leader会包含已经被提交的所有log entries。\nRaft使用voting的方法来保证leader拥有所有的log entries。candidate发送带有自己所有log entries的RequestVote RPC给其他server，如果其他server发现candidate的log entries没有自己新，则否决该candidate。\n判断log entries新旧方法：比较最后一个log entry的index和term，term编号更大的更新，如果term编号一样，则index更大的更新\n\n### 提交限制\nleader只能提交当前term中的log entry，相当于间接提交了其他term的log entry\n\n# 课堂记录\n## 脑裂\n之前提到的容错系统mapreduce、GFS、Vmware FT，都是单主节点。单主节点本身就是一个单点障碍，一旦出错就比较麻烦。\n主节点出错的一个方式是split brain(脑裂)，也就是说系统中存在多个主节点，可能会导致系统中出现各种矛盾和错误\n解决方案包括两种\n1. 构建完美的网络：高成本\n2. 人工解决问题：慢","slug":"DS-Lecture4 Raft","published":1,"updated":"2023-10-08T02:19:42.818Z","_id":"clncyc9zd00050wt623ntcf7d","comments":1,"layout":"post","photos":[],"link":"","content":"<p>分布式协同算法 Raft</p>\n<span id=\"more\"></span>\n\n<h1 id=\"论文阅读\"><a href=\"#论文阅读\" class=\"headerlink\" title=\"论文阅读\"></a>论文阅读</h1><p>以前的算法存在两个问题，1. 不容易理解2.对于现实问题没有好的基础，所以raft设计的目标就是好理解。为此，Raft使用了两个方法，1.问题分解2.简化系统状态<br>raft算法核心是leader，leader的产生简化了系统，因为leader可以决定新日志条目存放的地方，数据流也只从leader流向其他server。系统最简单来说就是两步</p>\n<ol>\n<li>选举leader</li>\n<li>leader管理复制日志</li>\n</ol>\n<p>具体而言，Raft将问题分解为以下几个子问题</p>\n<ol>\n<li><strong>leader选举</strong></li>\n<li><strong>日志复制</strong>：leader管理</li>\n<li><strong>安全</strong>：保证系统属性安全</li>\n</ol>\n<h2 id=\"Raft基础\"><a href=\"#Raft基础\" class=\"headerlink\" title=\"Raft基础\"></a>Raft基础</h2><h3 id=\"状态state\"><a href=\"#状态state\" class=\"headerlink\" title=\"状态state\"></a>状态state</h3><p>系统中的server有三个状态 <code>leader</code>、<code>follower</code>、<code>candidate</code>。<br><code>follower</code>是完全被动的接收来自其他两种server的指令；<code>leader</code>会处理所有来自client的请求，其他server也将请求转发给 <code>leader</code>；<code>candidate</code>则是选举过程中的中间状态。</p>\n<pre class=\"mermaid\">graph TD\n    A[Follower] -->|开始选举| B(Candidate)\n    B --> |重新选举|B\n    B --> |获得大多数选票| C(Leader)\n    C --> |其他server有更大的term编号| A\n    B --> |当前系统有leader了or其他server有更大的term编号| A</pre>\n\n<h3 id=\"时间片term\"><a href=\"#时间片term\" class=\"headerlink\" title=\"时间片term\"></a>时间片term</h3><p>系统的term（时间片）是任意(随机)长度的，每一个term都由选举开始，如果选举失败，该term立即终止，马上进入下一个term。Raft始终保证系统中有且仅有一个leader。<br>系统中的server保存了当前的term编号，如果server发现自己的term编号比其他server小，则自增到新的term编号，如果leader或candidate发现自己的编号过时了，则马上降级到follower<br>如果server收到了term编号不对的请求，将该请求丢弃。</p>\n<h3 id=\"通信-RPC\"><a href=\"#通信-RPC\" class=\"headerlink\" title=\"通信 RPC\"></a>通信 RPC</h3><p>系统中需要三条RPC通信路径</p>\n<ol>\n<li><strong>RequestVote RPCs</strong>：在选举过程中，由候选者初始化</li>\n<li><strong>AppendEntries RPCs</strong>：由leader初始化，在系统运行时提供日志条目复制和心跳功能</li>\n<li><strong>TransferSnapshot RPCs</strong>：传递server快照的RPCs</li>\n</ol>\n<h2 id=\"Raft性质\"><a href=\"#Raft性质\" class=\"headerlink\" title=\"Raft性质\"></a>Raft性质</h2><p>Raft算法运行中全程保证这些性质成立</p>\n<ol>\n<li><strong>选举安全</strong>：一个term中至多存在一个leader</li>\n<li><strong>leader仅追加log</strong>：leader的log不会被其他server覆写</li>\n<li><strong>log匹配</strong>：两个拥有相同index和term的log必然完全相同，且前序log也相同</li>\n<li><strong>leader完整性</strong>：committed的log entry一定会在后续的leader log中出现</li>\n<li><strong>状态机安全性</strong>：</li>\n</ol>\n<h2 id=\"选举\"><a href=\"#选举\" class=\"headerlink\" title=\"选举\"></a>选举</h2><p>server以follower身份启动，leader会定时发心跳信息（无日志信息的appendEntries）给follower维护自己的leader地位。当follower超时未收到心跳信息时则开启选举。<br>选举过程是follower将term编号自增并进入candidate状态，然后给自己投票，并向其他server并行发出RequestVote RPCs请求票。<br>每个server在一个term里至多给一个server投票，投票遵循先到先得原则。</p>\n<h3 id=\"选举结果\"><a href=\"#选举结果\" class=\"headerlink\" title=\"选举结果\"></a>选举结果</h3><p>candidates状态的结果有三种：</p>\n<ol>\n<li>获取大部分选票，赢得选举-&gt;leader 开始发心跳信息维护自己的leader地位</li>\n<li>收到了其他server的RequestVote RPCs，若其term编号大于等于自己，则认定其为合法leader-&gt;follower （否则自己仍为candidate）</li>\n<li>当多个server同时进入candidate状态并发送RequestVote RPCs，没人赢得选举-&gt;candidate 重启选举流程</li>\n</ol>\n<h3 id=\"随机超时机制\"><a href=\"#随机超时机制\" class=\"headerlink\" title=\"随机超时机制\"></a>随机超时机制</h3><p>为了保证系统尽量少进入第三个状态，即无人赢得选举，不停地选举，Raft采用随机的超时时限（150-300ms之间）。这样可以保证在在某一个时刻，只有一个server发现超时，并赢得选举。<br>每一个candidate在term开始时重新获取一个随机超时时限，</p>\n<h2 id=\"日志复制\"><a href=\"#日志复制\" class=\"headerlink\" title=\"日志复制\"></a>日志复制</h2><p>当client发送命令时，系统中会按顺序发生如下事件：</p>\n<ol>\n<li>leader追加一个新的log entry，也就是这条命令</li>\n<li>发布AppendEntries RPCs给其他server</li>\n<li>当这个entry完成安全的复制后，leader会执行该命令</li>\n<li>返回执行结果给client</li>\n</ol>\n<h3 id=\"日志内容\"><a href=\"#日志内容\" class=\"headerlink\" title=\"日志内容\"></a>日志内容</h3><p>日志将包含两个部分：</p>\n<ol>\n<li>状态机命令</li>\n<li>term编号：标记这条命令产生的时期</li>\n</ol>\n<h3 id=\"commited-entry\"><a href=\"#commited-entry\" class=\"headerlink\" title=\"commited entry\"></a>commited entry</h3><ul>\n<li>当entry被大多数（为什么是大多数？）server复制时，该log entry会变成commited状态。Raft将会保证系统中commited的entry被持久化以及被所有server执行。</li>\n<li>当一条log entry是commited时，这条日志之前的所有entries都会被commit，不论任何leader产生的。</li>\n<li>leader会追踪将要commit的最早entry，并用其发送appendEntries RPCs</li>\n<li>当follower得知entry被commit以后，就会执行该entry包含的命令</li>\n</ul>\n<h3 id=\"运行时日志一致性保证\"><a href=\"#运行时日志一致性保证\" class=\"headerlink\" title=\"运行时日志一致性保证\"></a>运行时日志一致性保证</h3><p>日志有两个属性</p>\n<ul>\n<li>index和term相同的log，命令必然相同</li>\n<li>index和term相同的log，前置log必然相同</li>\n</ul>\n<p>发送AppendEntries RPC时，leader会将前一个log的index和term也附上，如果follower没找到前一个log，那也不读入当前log</p>\n<h3 id=\"leader对日志一致性保证\"><a href=\"#leader对日志一致性保证\" class=\"headerlink\" title=\"leader对日志一致性保证\"></a>leader对日志一致性保证</h3><p>正常运行时，leader和多个follower的日志将会保持一致，当leader挂掉重新选举时，可能会导致日志出现不一致的现象，此时leader将自己的log强制复制给follower。leader会为<strong>每个follower</strong>更新nextIndex，用来指示向特定follower发送的下一条log entry。具体做法是：</p>\n<ol>\n<li><strong>初始化</strong>：将nextIndex初始化为leader的最后一条log entry的下一条</li>\n<li><strong>试错</strong>：给follower发送下一条的AppendEntries，如果失败，nextIndex–（也可以通过返回entries，让leader直接查找nextIndex）</li>\n<li><strong>结果</strong>：当AppendEntries成功时，正确的nextIndex就找到了</li>\n<li><strong>更新</strong>：将leader后续的log entries通过AppendEntries发送给follower，覆盖掉不一致的日志</li>\n</ol>\n<p>通过这些措施，leader在选举成功后，就会让整个系统里的follower逐渐收敛到自己的日志中来。同时，leader是不会删除（覆盖）自己的日志，只会覆盖掉follower的日志</p>\n<h2 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h2><h3 id=\"选举限制\"><a href=\"#选举限制\" class=\"headerlink\" title=\"选举限制\"></a>选举限制</h3><p>为了简化算法，只允许log entries从leader流向follower，Raft保证leader会包含已经被提交的所有log entries。<br>Raft使用voting的方法来保证leader拥有所有的log entries。candidate发送带有自己所有log entries的RequestVote RPC给其他server，如果其他server发现candidate的log entries没有自己新，则否决该candidate。<br>判断log entries新旧方法：比较最后一个log entry的index和term，term编号更大的更新，如果term编号一样，则index更大的更新</p>\n<h3 id=\"提交限制\"><a href=\"#提交限制\" class=\"headerlink\" title=\"提交限制\"></a>提交限制</h3><p>leader只能提交当前term中的log entry，相当于间接提交了其他term的log entry</p>\n<h1 id=\"课堂记录\"><a href=\"#课堂记录\" class=\"headerlink\" title=\"课堂记录\"></a>课堂记录</h1><h2 id=\"脑裂\"><a href=\"#脑裂\" class=\"headerlink\" title=\"脑裂\"></a>脑裂</h2><p>之前提到的容错系统mapreduce、GFS、Vmware FT，都是单主节点。单主节点本身就是一个单点障碍，一旦出错就比较麻烦。<br>主节点出错的一个方式是split brain(脑裂)，也就是说系统中存在多个主节点，可能会导致系统中出现各种矛盾和错误<br>解决方案包括两种</p>\n<ol>\n<li>构建完美的网络：高成本</li>\n<li>人工解决问题：慢</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>分布式协同算法 Raft</p>","more":"<h1 id=\"论文阅读\"><a href=\"#论文阅读\" class=\"headerlink\" title=\"论文阅读\"></a>论文阅读</h1><p>以前的算法存在两个问题，1. 不容易理解2.对于现实问题没有好的基础，所以raft设计的目标就是好理解。为此，Raft使用了两个方法，1.问题分解2.简化系统状态<br>raft算法核心是leader，leader的产生简化了系统，因为leader可以决定新日志条目存放的地方，数据流也只从leader流向其他server。系统最简单来说就是两步</p>\n<ol>\n<li>选举leader</li>\n<li>leader管理复制日志</li>\n</ol>\n<p>具体而言，Raft将问题分解为以下几个子问题</p>\n<ol>\n<li><strong>leader选举</strong></li>\n<li><strong>日志复制</strong>：leader管理</li>\n<li><strong>安全</strong>：保证系统属性安全</li>\n</ol>\n<h2 id=\"Raft基础\"><a href=\"#Raft基础\" class=\"headerlink\" title=\"Raft基础\"></a>Raft基础</h2><h3 id=\"状态state\"><a href=\"#状态state\" class=\"headerlink\" title=\"状态state\"></a>状态state</h3><p>系统中的server有三个状态 <code>leader</code>、<code>follower</code>、<code>candidate</code>。<br><code>follower</code>是完全被动的接收来自其他两种server的指令；<code>leader</code>会处理所有来自client的请求，其他server也将请求转发给 <code>leader</code>；<code>candidate</code>则是选举过程中的中间状态。</p>\n<pre class=\"mermaid\">graph TD\n    A[Follower] -->|开始选举| B(Candidate)\n    B --> |重新选举|B\n    B --> |获得大多数选票| C(Leader)\n    C --> |其他server有更大的term编号| A\n    B --> |当前系统有leader了or其他server有更大的term编号| A</pre>\n\n<h3 id=\"时间片term\"><a href=\"#时间片term\" class=\"headerlink\" title=\"时间片term\"></a>时间片term</h3><p>系统的term（时间片）是任意(随机)长度的，每一个term都由选举开始，如果选举失败，该term立即终止，马上进入下一个term。Raft始终保证系统中有且仅有一个leader。<br>系统中的server保存了当前的term编号，如果server发现自己的term编号比其他server小，则自增到新的term编号，如果leader或candidate发现自己的编号过时了，则马上降级到follower<br>如果server收到了term编号不对的请求，将该请求丢弃。</p>\n<h3 id=\"通信-RPC\"><a href=\"#通信-RPC\" class=\"headerlink\" title=\"通信 RPC\"></a>通信 RPC</h3><p>系统中需要三条RPC通信路径</p>\n<ol>\n<li><strong>RequestVote RPCs</strong>：在选举过程中，由候选者初始化</li>\n<li><strong>AppendEntries RPCs</strong>：由leader初始化，在系统运行时提供日志条目复制和心跳功能</li>\n<li><strong>TransferSnapshot RPCs</strong>：传递server快照的RPCs</li>\n</ol>\n<h2 id=\"Raft性质\"><a href=\"#Raft性质\" class=\"headerlink\" title=\"Raft性质\"></a>Raft性质</h2><p>Raft算法运行中全程保证这些性质成立</p>\n<ol>\n<li><strong>选举安全</strong>：一个term中至多存在一个leader</li>\n<li><strong>leader仅追加log</strong>：leader的log不会被其他server覆写</li>\n<li><strong>log匹配</strong>：两个拥有相同index和term的log必然完全相同，且前序log也相同</li>\n<li><strong>leader完整性</strong>：committed的log entry一定会在后续的leader log中出现</li>\n<li><strong>状态机安全性</strong>：</li>\n</ol>\n<h2 id=\"选举\"><a href=\"#选举\" class=\"headerlink\" title=\"选举\"></a>选举</h2><p>server以follower身份启动，leader会定时发心跳信息（无日志信息的appendEntries）给follower维护自己的leader地位。当follower超时未收到心跳信息时则开启选举。<br>选举过程是follower将term编号自增并进入candidate状态，然后给自己投票，并向其他server并行发出RequestVote RPCs请求票。<br>每个server在一个term里至多给一个server投票，投票遵循先到先得原则。</p>\n<h3 id=\"选举结果\"><a href=\"#选举结果\" class=\"headerlink\" title=\"选举结果\"></a>选举结果</h3><p>candidates状态的结果有三种：</p>\n<ol>\n<li>获取大部分选票，赢得选举-&gt;leader 开始发心跳信息维护自己的leader地位</li>\n<li>收到了其他server的RequestVote RPCs，若其term编号大于等于自己，则认定其为合法leader-&gt;follower （否则自己仍为candidate）</li>\n<li>当多个server同时进入candidate状态并发送RequestVote RPCs，没人赢得选举-&gt;candidate 重启选举流程</li>\n</ol>\n<h3 id=\"随机超时机制\"><a href=\"#随机超时机制\" class=\"headerlink\" title=\"随机超时机制\"></a>随机超时机制</h3><p>为了保证系统尽量少进入第三个状态，即无人赢得选举，不停地选举，Raft采用随机的超时时限（150-300ms之间）。这样可以保证在在某一个时刻，只有一个server发现超时，并赢得选举。<br>每一个candidate在term开始时重新获取一个随机超时时限，</p>\n<h2 id=\"日志复制\"><a href=\"#日志复制\" class=\"headerlink\" title=\"日志复制\"></a>日志复制</h2><p>当client发送命令时，系统中会按顺序发生如下事件：</p>\n<ol>\n<li>leader追加一个新的log entry，也就是这条命令</li>\n<li>发布AppendEntries RPCs给其他server</li>\n<li>当这个entry完成安全的复制后，leader会执行该命令</li>\n<li>返回执行结果给client</li>\n</ol>\n<h3 id=\"日志内容\"><a href=\"#日志内容\" class=\"headerlink\" title=\"日志内容\"></a>日志内容</h3><p>日志将包含两个部分：</p>\n<ol>\n<li>状态机命令</li>\n<li>term编号：标记这条命令产生的时期</li>\n</ol>\n<h3 id=\"commited-entry\"><a href=\"#commited-entry\" class=\"headerlink\" title=\"commited entry\"></a>commited entry</h3><ul>\n<li>当entry被大多数（为什么是大多数？）server复制时，该log entry会变成commited状态。Raft将会保证系统中commited的entry被持久化以及被所有server执行。</li>\n<li>当一条log entry是commited时，这条日志之前的所有entries都会被commit，不论任何leader产生的。</li>\n<li>leader会追踪将要commit的最早entry，并用其发送appendEntries RPCs</li>\n<li>当follower得知entry被commit以后，就会执行该entry包含的命令</li>\n</ul>\n<h3 id=\"运行时日志一致性保证\"><a href=\"#运行时日志一致性保证\" class=\"headerlink\" title=\"运行时日志一致性保证\"></a>运行时日志一致性保证</h3><p>日志有两个属性</p>\n<ul>\n<li>index和term相同的log，命令必然相同</li>\n<li>index和term相同的log，前置log必然相同</li>\n</ul>\n<p>发送AppendEntries RPC时，leader会将前一个log的index和term也附上，如果follower没找到前一个log，那也不读入当前log</p>\n<h3 id=\"leader对日志一致性保证\"><a href=\"#leader对日志一致性保证\" class=\"headerlink\" title=\"leader对日志一致性保证\"></a>leader对日志一致性保证</h3><p>正常运行时，leader和多个follower的日志将会保持一致，当leader挂掉重新选举时，可能会导致日志出现不一致的现象，此时leader将自己的log强制复制给follower。leader会为<strong>每个follower</strong>更新nextIndex，用来指示向特定follower发送的下一条log entry。具体做法是：</p>\n<ol>\n<li><strong>初始化</strong>：将nextIndex初始化为leader的最后一条log entry的下一条</li>\n<li><strong>试错</strong>：给follower发送下一条的AppendEntries，如果失败，nextIndex–（也可以通过返回entries，让leader直接查找nextIndex）</li>\n<li><strong>结果</strong>：当AppendEntries成功时，正确的nextIndex就找到了</li>\n<li><strong>更新</strong>：将leader后续的log entries通过AppendEntries发送给follower，覆盖掉不一致的日志</li>\n</ol>\n<p>通过这些措施，leader在选举成功后，就会让整个系统里的follower逐渐收敛到自己的日志中来。同时，leader是不会删除（覆盖）自己的日志，只会覆盖掉follower的日志</p>\n<h2 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h2><h3 id=\"选举限制\"><a href=\"#选举限制\" class=\"headerlink\" title=\"选举限制\"></a>选举限制</h3><p>为了简化算法，只允许log entries从leader流向follower，Raft保证leader会包含已经被提交的所有log entries。<br>Raft使用voting的方法来保证leader拥有所有的log entries。candidate发送带有自己所有log entries的RequestVote RPC给其他server，如果其他server发现candidate的log entries没有自己新，则否决该candidate。<br>判断log entries新旧方法：比较最后一个log entry的index和term，term编号更大的更新，如果term编号一样，则index更大的更新</p>\n<h3 id=\"提交限制\"><a href=\"#提交限制\" class=\"headerlink\" title=\"提交限制\"></a>提交限制</h3><p>leader只能提交当前term中的log entry，相当于间接提交了其他term的log entry</p>\n<h1 id=\"课堂记录\"><a href=\"#课堂记录\" class=\"headerlink\" title=\"课堂记录\"></a>课堂记录</h1><h2 id=\"脑裂\"><a href=\"#脑裂\" class=\"headerlink\" title=\"脑裂\"></a>脑裂</h2><p>之前提到的容错系统mapreduce、GFS、Vmware FT，都是单主节点。单主节点本身就是一个单点障碍，一旦出错就比较麻烦。<br>主节点出错的一个方式是split brain(脑裂)，也就是说系统中存在多个主节点，可能会导致系统中出现各种矛盾和错误<br>解决方案包括两种</p>\n<ol>\n<li>构建完美的网络：高成本</li>\n<li>人工解决问题：慢</li>\n</ol>"},{"title":"多状态DP：买卖股票的最佳时机 III","date":"2023-09-30T02:57:29.000Z","_content":"一道很有意思的DP题目\n<!-- more -->\n\n# 题目\n[leetcode链接：买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)\n# 题解\n根据题意可以将买卖股票划分成五个状态\n1. 完全没交易\n2. 买了第一次\n3. 卖了第一次，还没买第二次\n4. 买了第二次\n5. 卖了第二次\n这五个状态可以从上向下转换，将2-4编号为buy1 sell1 buy2 sell2，可以得出，状态转移方程\n```\nbuy1 = max(buy1, -prices[i]);\nsell1 = max(buy1 + prices[i], sell1);\nbuy2 = max(sell1 - prices[i], buy2);\nsell2 = max(sell2, buy2 + prices[i]);\n```\n这个题有意思的点就在于状态多，识别状态有点困难\n# 代码\n```c\nclass Solution {\npublic:\n    int max(int a, int b) {\n        if (a > b) return a;\n        return b;\n    }\n    int maxProfit(vector<int>& prices) {\n        int buy1 = -prices[0], buy2 = buy1, sell1 = 0, sell2 = 0;\n        for (int i = 0; i < prices.size(); ++i) {\n            buy1 = max(buy1, -prices[i]);\n            sell1 = max(buy1 + prices[i], sell1);\n            buy2 = max(sell1 - prices[i], buy2);\n            sell2 = max(sell2, buy2 + prices[i]);\n        }\n        return max(0, max(sell1, sell2));\n    }\n};\n```\n# 升级版题目\n## 题目\n[leetcode链接：买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)\n## 题解\n类似于上一题，将不同状态进一步抽象为数组表示\n## 代码\n```c\nclass Solution {\npublic:\n    int max(int a, int b) {\n        if (a < b) return b;\n        return a;\n    }\n    int maxProfit(int k, vector<int>& prices) {\n        vector<int> buy(k + 1, -prices[0]), sell(k + 1, 0);\n        int ans = 0;\n        for (int i = 0; i < prices.size(); ++i) {\n            buy[0] = max(buy[0], -prices[i]);\n            for (int j = 1; j <= k; ++j) {\n                buy[j] = max(buy[j], sell[j - 1] - prices[i]);\n                sell[j] = max(sell[j], buy[j] + prices[i]);\n                ans = max(ans, sell[j]);\n            }\n        }\n        return ans;\n    }\n};\n```","source":"_posts/多状态DP.md","raw":"---\ntitle: 多状态DP：买卖股票的最佳时机 III\ndate: 2023-09-30 10:57:29\ntags:\n---\n一道很有意思的DP题目\n<!-- more -->\n\n# 题目\n[leetcode链接：买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)\n# 题解\n根据题意可以将买卖股票划分成五个状态\n1. 完全没交易\n2. 买了第一次\n3. 卖了第一次，还没买第二次\n4. 买了第二次\n5. 卖了第二次\n这五个状态可以从上向下转换，将2-4编号为buy1 sell1 buy2 sell2，可以得出，状态转移方程\n```\nbuy1 = max(buy1, -prices[i]);\nsell1 = max(buy1 + prices[i], sell1);\nbuy2 = max(sell1 - prices[i], buy2);\nsell2 = max(sell2, buy2 + prices[i]);\n```\n这个题有意思的点就在于状态多，识别状态有点困难\n# 代码\n```c\nclass Solution {\npublic:\n    int max(int a, int b) {\n        if (a > b) return a;\n        return b;\n    }\n    int maxProfit(vector<int>& prices) {\n        int buy1 = -prices[0], buy2 = buy1, sell1 = 0, sell2 = 0;\n        for (int i = 0; i < prices.size(); ++i) {\n            buy1 = max(buy1, -prices[i]);\n            sell1 = max(buy1 + prices[i], sell1);\n            buy2 = max(sell1 - prices[i], buy2);\n            sell2 = max(sell2, buy2 + prices[i]);\n        }\n        return max(0, max(sell1, sell2));\n    }\n};\n```\n# 升级版题目\n## 题目\n[leetcode链接：买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)\n## 题解\n类似于上一题，将不同状态进一步抽象为数组表示\n## 代码\n```c\nclass Solution {\npublic:\n    int max(int a, int b) {\n        if (a < b) return b;\n        return a;\n    }\n    int maxProfit(int k, vector<int>& prices) {\n        vector<int> buy(k + 1, -prices[0]), sell(k + 1, 0);\n        int ans = 0;\n        for (int i = 0; i < prices.size(); ++i) {\n            buy[0] = max(buy[0], -prices[i]);\n            for (int j = 1; j <= k; ++j) {\n                buy[j] = max(buy[j], sell[j - 1] - prices[i]);\n                sell[j] = max(sell[j], buy[j] + prices[i]);\n                ans = max(ans, sell[j]);\n            }\n        }\n        return ans;\n    }\n};\n```","slug":"多状态DP","published":1,"updated":"2023-09-30T06:48:59.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clncyc9ze00060wt602kqakj9","content":"<p>一道很有意思的DP题目</p>\n<span id=\"more\"></span>\n\n<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/\">leetcode链接：买卖股票的最佳时机 III</a></p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><p>根据题意可以将买卖股票划分成五个状态</p>\n<ol>\n<li>完全没交易</li>\n<li>买了第一次</li>\n<li>卖了第一次，还没买第二次</li>\n<li>买了第二次</li>\n<li>卖了第二次<br>这五个状态可以从上向下转换，将2-4编号为buy1 sell1 buy2 sell2，可以得出，状态转移方程<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buy1 = max(buy1, -prices[i]);</span><br><span class=\"line\">sell1 = max(buy1 + prices[i], sell1);</span><br><span class=\"line\">buy2 = max(sell1 - prices[i], buy2);</span><br><span class=\"line\">sell2 = max(sell2, buy2 + prices[i]);</span><br></pre></td></tr></table></figure>\n这个题有意思的点就在于状态多，识别状态有点困难</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &gt; b) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> buy1 = -prices[<span class=\"number\">0</span>], buy2 = buy1, sell1 = <span class=\"number\">0</span>, sell2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class=\"line\">            buy1 = max(buy1, -prices[i]);</span><br><span class=\"line\">            sell1 = max(buy1 + prices[i], sell1);</span><br><span class=\"line\">            buy2 = max(sell1 - prices[i], buy2);</span><br><span class=\"line\">            sell2 = max(sell2, buy2 + prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(<span class=\"number\">0</span>, max(sell1, sell2));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"升级版题目\"><a href=\"#升级版题目\" class=\"headerlink\" title=\"升级版题目\"></a>升级版题目</h1><h2 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/\">leetcode链接：买卖股票的最佳时机 IV</a></p>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>类似于上一题，将不同状态进一步抽象为数组表示</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; b) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; <span class=\"title function_\">buy</span><span class=\"params\">(k + <span class=\"number\">1</span>, -prices[<span class=\"number\">0</span>])</span>, <span class=\"title function_\">sell</span><span class=\"params\">(k + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class=\"line\">            buy[<span class=\"number\">0</span>] = max(buy[<span class=\"number\">0</span>], -prices[i]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= k; ++j) &#123;</span><br><span class=\"line\">                buy[j] = max(buy[j], sell[j - <span class=\"number\">1</span>] - prices[i]);</span><br><span class=\"line\">                sell[j] = max(sell[j], buy[j] + prices[i]);</span><br><span class=\"line\">                ans = max(ans, sell[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一道很有意思的DP题目</p>","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><p><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/\">leetcode链接：买卖股票的最佳时机 III</a></p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h1><p>根据题意可以将买卖股票划分成五个状态</p>\n<ol>\n<li>完全没交易</li>\n<li>买了第一次</li>\n<li>卖了第一次，还没买第二次</li>\n<li>买了第二次</li>\n<li>卖了第二次<br>这五个状态可以从上向下转换，将2-4编号为buy1 sell1 buy2 sell2，可以得出，状态转移方程<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buy1 = max(buy1, -prices[i]);</span><br><span class=\"line\">sell1 = max(buy1 + prices[i], sell1);</span><br><span class=\"line\">buy2 = max(sell1 - prices[i], buy2);</span><br><span class=\"line\">sell2 = max(sell2, buy2 + prices[i]);</span><br></pre></td></tr></table></figure>\n这个题有意思的点就在于状态多，识别状态有点困难</li>\n</ol>\n<h1 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &gt; b) <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> buy1 = -prices[<span class=\"number\">0</span>], buy2 = buy1, sell1 = <span class=\"number\">0</span>, sell2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class=\"line\">            buy1 = max(buy1, -prices[i]);</span><br><span class=\"line\">            sell1 = max(buy1 + prices[i], sell1);</span><br><span class=\"line\">            buy2 = max(sell1 - prices[i], buy2);</span><br><span class=\"line\">            sell2 = max(sell2, buy2 + prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(<span class=\"number\">0</span>, max(sell1, sell2));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"升级版题目\"><a href=\"#升级版题目\" class=\"headerlink\" title=\"升级版题目\"></a>升级版题目</h1><h2 id=\"题目-1\"><a href=\"#题目-1\" class=\"headerlink\" title=\"题目\"></a>题目</h2><p><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/\">leetcode链接：买卖股票的最佳时机 IV</a></p>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"></a>题解</h2><p>类似于上一题，将不同状态进一步抽象为数组表示</p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\">public:</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">max</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a &lt; b) <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;&amp; prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt; <span class=\"title function_\">buy</span><span class=\"params\">(k + <span class=\"number\">1</span>, -prices[<span class=\"number\">0</span>])</span>, <span class=\"title function_\">sell</span><span class=\"params\">(k + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; prices.size(); ++i) &#123;</span><br><span class=\"line\">            buy[<span class=\"number\">0</span>] = max(buy[<span class=\"number\">0</span>], -prices[i]);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= k; ++j) &#123;</span><br><span class=\"line\">                buy[j] = max(buy[j], sell[j - <span class=\"number\">1</span>] - prices[i]);</span><br><span class=\"line\">                sell[j] = max(sell[j], buy[j] + prices[i]);</span><br><span class=\"line\">                ans = max(ans, sell[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"layout":"ds_lab2","title":"分布式系统 GFS","date":"2023-09-30T06:51:56.000Z","_content":"Google File System，有点古老的技术，但技术仍存在参考意义\n<!-- more -->\n\n# 论文阅读\n## 背景\nGoogle有大量数据存储的要求，所以诞生了GFS这个大规模分布式文件存储系统。根据工作负载和技术环境，GFS和传统文件系统有以下区别：\n1. **组件故障是常态** 分布式设备廉价容易出故障，而且不易恢复。\n2. **文件大**\n3. **修改==追加** 不存在对文件的随机写，一旦写入就不再修改，通过追加的方式进行修改\n4. 多客户端可能同时对文件进行原子追加操作\n5. 高带宽比低延迟更重要\n## 架构\nGFS集群由1个**Master**、n个**chunk server**、m个client组成。\n这些东西都跑在普通的Linux服务器上。chunk server和client是可以在同一台服务器上跑的。\n### 文件\n1. 文件会被分块，每一块叫做一个chunk。\n2. 每个chunk有一个64位的唯一标识chunk handle，这个标识是在分块的时候由master产生的。\n3. 文件存储在chunk server上，通过chunk handle和字节范围读写。\n4. 文件会存在副本，可以设置不同命名空间中文件的不同副本数量\n### 存储与交互\nmaster存储文件系统的元信息，包括以下内容：\n1. 名字空间 namespace（文件名）\n2. 文件->块 映射信息\n3. chunk位置信息（不需要持久化）\n4. 访问控制信息 \nmaster还控制了系统活动，如\n1. 租约管理\n2. 孤儿块垃圾回收\n3. chunk server之间的块迁移\n4. master用心跳信息管理chunk server状态\nclient绝不跟master要数据，而是向master要元信息，发送一个包含文件名和块索引的请求，master返回chunk handle和副本位置；然后client再向chunk master请求具体文件。\n这么做保证了单master的可行性\n# 课程记录\n## 分布式存储的难点\n追求**高性能**->将文件**分片**放在多个服务器上->更容易发生**故障**->需要**容错**措施->建立**副本**->追求**一致性***->**低性能**\n## GFS特点\n1. **单数据中心**：只在一个数据中心运行\n2. **工业软件**：不面向普通用户\n3. **大规模顺序读写**：不支持随机访问，更关注吞吐量（带宽）而不是时延\n4. **弱一致性**：保证性能\n5. **单master**\n## GFS结构\nmaster 存储元信息，chunk server 存储数据信息。两种服务器相互隔离\n### Master存储信息\nmaster中主要有两张表：\n1. filename-> chunk handle（需要**持久化**）\n2. chunk handle->chunk servers\n * chunk servers服务器列表：每个Chunk存储在哪些服务器上\n * chunk版本号：每个Chunk当前的版本号（需要**持久化**）\n * 主chunk地址：所有对于Chunk的写操作都必须在主Chunk（Primary Chunk）上顺序处理，主Chunk是Chunk的多个副本之一。所以，Master节点必须记住哪个Chunk服务器持有主Chunk。\n * 主chunk租约到期时间：主Chunk只能在特定的租约时间内担任主Chunk，所以，Master节点要记住主Chunk的租约过期时间。\n\n 持久化的方式是**写日志**和**打检查点**。\n * 加入新chunk或者修改chunk版本时需要向磁盘写一条日志\n * 定时打checkpoints，将状态转移到磁盘中，恢复时选择最近的checkpoints，从该checkpoint后的日志开始恢复，而不必从猴年马月开始恢复。\n\n## Read读数据\n### client和master 元信息交互\n1. client 发送[filename文件名, offset偏移量]给master\n2. master从filename->chunk handle中查询**chunk handle**，offset / chunk size 就是chunk handle在数组中的index，从而可以获取chunk handle\n3. master从chunk handle->chunk servers中查询**chunk server**的信息\n4. master将[chunk handle, chunk server]发送给client\nclient 会缓存 master返回的信息，因为可能会持续访问这个chunk\n如果跨chunk访问，client端会自动分成两个读请求发给master\n### client和chunk server 数据交互\n1. client 将[chunk handle, byte range]发送给选中的chunk server\n2. chunk server根据chunk handle找到文件，根据byte range获取数据，发回给client\n\n## Write写数据\nGFS只追加数据，而不随机写数据。写数据时需要向持有primary chunk（主副本）的chunk server写入，当不清楚primary chunk时，需要进行以下操作\n### 确定primary\n1. 找到**最新副本**：chunk版本号==master中记录chunk的版本号\n2. 选中**primary chunk**：选择其中一个chunk server作为primary chunk，其他的就是secondary。primary是有租约的，超时过期就失去了primary的地位，为了避免同时出现两个primary，就算master联系不上primary，也会等待租约到期。\n3. 版本号自增\n4. 告诉chunk server，primary、secondary 版本号\n5. master写入版本号\n\n注意：\n * 版本号是master指定primary时才会产生的\n## 客户端和primary的交互\n1. 客户端将数据往chunk server（primary & secondary）发\n2. chunk server会将数据写入临时区，并给client返回确认信息\n3. client给primary发送确定信息，意义为：你和所有secondary都有了数据，请写入chunk末尾\n4. primary调度并发请求，并以某种顺序，保证一次只执行一个请求，给所有secondary发送写请求\n5. 所有chunk server收到写请求后，将临时区的数据往chunk里写，完成后给primary发送确认信息，意义为：已经成功写入数据\n6. 如果primary收到了所有secondary的确认消息，则返回给client确认消息，否则，若存在一个异常（secondary没有回复or回复错误信息），primary向client报告失败\n7. client收到失败信息后会重新发起数据追加操作\n\n写文件失败的一些事项\n * 部分chunk server确实写入了，所以存在读到新数据的可能\n## GFS一致性\n如果整套流程成功走下来，则系统各副本一致。\n假如存在个别副本失败，则重新发一遍请求，在新的位置写入，所以读不同副本可能会读到不同的数据（有的可能有多套数据，有的可能只有一套，假如client也挂了，那可能存在一套数据都没有的副本）\n多副本不一致，设计方式简单，但是容易出错。（有点拉）","source":"_posts/DS_Lecture2 GFS.md","raw":"---\nlayout: ds_lab2\ntitle: 分布式系统 GFS\ndate: 2023-09-30 14:51:56\ntags:\n    - mit 6.824\n    - 分布式系统\n    - GFS\n---\nGoogle File System，有点古老的技术，但技术仍存在参考意义\n<!-- more -->\n\n# 论文阅读\n## 背景\nGoogle有大量数据存储的要求，所以诞生了GFS这个大规模分布式文件存储系统。根据工作负载和技术环境，GFS和传统文件系统有以下区别：\n1. **组件故障是常态** 分布式设备廉价容易出故障，而且不易恢复。\n2. **文件大**\n3. **修改==追加** 不存在对文件的随机写，一旦写入就不再修改，通过追加的方式进行修改\n4. 多客户端可能同时对文件进行原子追加操作\n5. 高带宽比低延迟更重要\n## 架构\nGFS集群由1个**Master**、n个**chunk server**、m个client组成。\n这些东西都跑在普通的Linux服务器上。chunk server和client是可以在同一台服务器上跑的。\n### 文件\n1. 文件会被分块，每一块叫做一个chunk。\n2. 每个chunk有一个64位的唯一标识chunk handle，这个标识是在分块的时候由master产生的。\n3. 文件存储在chunk server上，通过chunk handle和字节范围读写。\n4. 文件会存在副本，可以设置不同命名空间中文件的不同副本数量\n### 存储与交互\nmaster存储文件系统的元信息，包括以下内容：\n1. 名字空间 namespace（文件名）\n2. 文件->块 映射信息\n3. chunk位置信息（不需要持久化）\n4. 访问控制信息 \nmaster还控制了系统活动，如\n1. 租约管理\n2. 孤儿块垃圾回收\n3. chunk server之间的块迁移\n4. master用心跳信息管理chunk server状态\nclient绝不跟master要数据，而是向master要元信息，发送一个包含文件名和块索引的请求，master返回chunk handle和副本位置；然后client再向chunk master请求具体文件。\n这么做保证了单master的可行性\n# 课程记录\n## 分布式存储的难点\n追求**高性能**->将文件**分片**放在多个服务器上->更容易发生**故障**->需要**容错**措施->建立**副本**->追求**一致性***->**低性能**\n## GFS特点\n1. **单数据中心**：只在一个数据中心运行\n2. **工业软件**：不面向普通用户\n3. **大规模顺序读写**：不支持随机访问，更关注吞吐量（带宽）而不是时延\n4. **弱一致性**：保证性能\n5. **单master**\n## GFS结构\nmaster 存储元信息，chunk server 存储数据信息。两种服务器相互隔离\n### Master存储信息\nmaster中主要有两张表：\n1. filename-> chunk handle（需要**持久化**）\n2. chunk handle->chunk servers\n * chunk servers服务器列表：每个Chunk存储在哪些服务器上\n * chunk版本号：每个Chunk当前的版本号（需要**持久化**）\n * 主chunk地址：所有对于Chunk的写操作都必须在主Chunk（Primary Chunk）上顺序处理，主Chunk是Chunk的多个副本之一。所以，Master节点必须记住哪个Chunk服务器持有主Chunk。\n * 主chunk租约到期时间：主Chunk只能在特定的租约时间内担任主Chunk，所以，Master节点要记住主Chunk的租约过期时间。\n\n 持久化的方式是**写日志**和**打检查点**。\n * 加入新chunk或者修改chunk版本时需要向磁盘写一条日志\n * 定时打checkpoints，将状态转移到磁盘中，恢复时选择最近的checkpoints，从该checkpoint后的日志开始恢复，而不必从猴年马月开始恢复。\n\n## Read读数据\n### client和master 元信息交互\n1. client 发送[filename文件名, offset偏移量]给master\n2. master从filename->chunk handle中查询**chunk handle**，offset / chunk size 就是chunk handle在数组中的index，从而可以获取chunk handle\n3. master从chunk handle->chunk servers中查询**chunk server**的信息\n4. master将[chunk handle, chunk server]发送给client\nclient 会缓存 master返回的信息，因为可能会持续访问这个chunk\n如果跨chunk访问，client端会自动分成两个读请求发给master\n### client和chunk server 数据交互\n1. client 将[chunk handle, byte range]发送给选中的chunk server\n2. chunk server根据chunk handle找到文件，根据byte range获取数据，发回给client\n\n## Write写数据\nGFS只追加数据，而不随机写数据。写数据时需要向持有primary chunk（主副本）的chunk server写入，当不清楚primary chunk时，需要进行以下操作\n### 确定primary\n1. 找到**最新副本**：chunk版本号==master中记录chunk的版本号\n2. 选中**primary chunk**：选择其中一个chunk server作为primary chunk，其他的就是secondary。primary是有租约的，超时过期就失去了primary的地位，为了避免同时出现两个primary，就算master联系不上primary，也会等待租约到期。\n3. 版本号自增\n4. 告诉chunk server，primary、secondary 版本号\n5. master写入版本号\n\n注意：\n * 版本号是master指定primary时才会产生的\n## 客户端和primary的交互\n1. 客户端将数据往chunk server（primary & secondary）发\n2. chunk server会将数据写入临时区，并给client返回确认信息\n3. client给primary发送确定信息，意义为：你和所有secondary都有了数据，请写入chunk末尾\n4. primary调度并发请求，并以某种顺序，保证一次只执行一个请求，给所有secondary发送写请求\n5. 所有chunk server收到写请求后，将临时区的数据往chunk里写，完成后给primary发送确认信息，意义为：已经成功写入数据\n6. 如果primary收到了所有secondary的确认消息，则返回给client确认消息，否则，若存在一个异常（secondary没有回复or回复错误信息），primary向client报告失败\n7. client收到失败信息后会重新发起数据追加操作\n\n写文件失败的一些事项\n * 部分chunk server确实写入了，所以存在读到新数据的可能\n## GFS一致性\n如果整套流程成功走下来，则系统各副本一致。\n假如存在个别副本失败，则重新发一遍请求，在新的位置写入，所以读不同副本可能会读到不同的数据（有的可能有多套数据，有的可能只有一套，假如client也挂了，那可能存在一套数据都没有的副本）\n多副本不一致，设计方式简单，但是容易出错。（有点拉）","slug":"DS_Lecture2 GFS","published":1,"updated":"2023-10-02T03:43:40.484Z","comments":1,"photos":[],"link":"","_id":"clncyc9zf00070wt69s8y5s2a","content":"<p>Google File System，有点古老的技术，但技术仍存在参考意义</p>\n<span id=\"more\"></span>\n\n<h1 id=\"论文阅读\"><a href=\"#论文阅读\" class=\"headerlink\" title=\"论文阅读\"></a>论文阅读</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>Google有大量数据存储的要求，所以诞生了GFS这个大规模分布式文件存储系统。根据工作负载和技术环境，GFS和传统文件系统有以下区别：</p>\n<ol>\n<li><strong>组件故障是常态</strong> 分布式设备廉价容易出故障，而且不易恢复。</li>\n<li><strong>文件大</strong></li>\n<li><strong>修改&#x3D;&#x3D;追加</strong> 不存在对文件的随机写，一旦写入就不再修改，通过追加的方式进行修改</li>\n<li>多客户端可能同时对文件进行原子追加操作</li>\n<li>高带宽比低延迟更重要</li>\n</ol>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><p>GFS集群由1个<strong>Master</strong>、n个<strong>chunk server</strong>、m个client组成。<br>这些东西都跑在普通的Linux服务器上。chunk server和client是可以在同一台服务器上跑的。</p>\n<h3 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h3><ol>\n<li>文件会被分块，每一块叫做一个chunk。</li>\n<li>每个chunk有一个64位的唯一标识chunk handle，这个标识是在分块的时候由master产生的。</li>\n<li>文件存储在chunk server上，通过chunk handle和字节范围读写。</li>\n<li>文件会存在副本，可以设置不同命名空间中文件的不同副本数量</li>\n</ol>\n<h3 id=\"存储与交互\"><a href=\"#存储与交互\" class=\"headerlink\" title=\"存储与交互\"></a>存储与交互</h3><p>master存储文件系统的元信息，包括以下内容：</p>\n<ol>\n<li>名字空间 namespace（文件名）</li>\n<li>文件-&gt;块 映射信息</li>\n<li>chunk位置信息（不需要持久化）</li>\n<li>访问控制信息<br>master还控制了系统活动，如</li>\n<li>租约管理</li>\n<li>孤儿块垃圾回收</li>\n<li>chunk server之间的块迁移</li>\n<li>master用心跳信息管理chunk server状态<br>client绝不跟master要数据，而是向master要元信息，发送一个包含文件名和块索引的请求，master返回chunk handle和副本位置；然后client再向chunk master请求具体文件。<br>这么做保证了单master的可行性</li>\n</ol>\n<h1 id=\"课程记录\"><a href=\"#课程记录\" class=\"headerlink\" title=\"课程记录\"></a>课程记录</h1><h2 id=\"分布式存储的难点\"><a href=\"#分布式存储的难点\" class=\"headerlink\" title=\"分布式存储的难点\"></a>分布式存储的难点</h2><p>追求<strong>高性能</strong>-&gt;将文件<strong>分片</strong>放在多个服务器上-&gt;更容易发生<strong>故障</strong>-&gt;需要<strong>容错</strong>措施-&gt;建立<strong>副本</strong>-&gt;追求<strong>一致性</strong>*-&gt;<strong>低性能</strong></p>\n<h2 id=\"GFS特点\"><a href=\"#GFS特点\" class=\"headerlink\" title=\"GFS特点\"></a>GFS特点</h2><ol>\n<li><strong>单数据中心</strong>：只在一个数据中心运行</li>\n<li><strong>工业软件</strong>：不面向普通用户</li>\n<li><strong>大规模顺序读写</strong>：不支持随机访问，更关注吞吐量（带宽）而不是时延</li>\n<li><strong>弱一致性</strong>：保证性能</li>\n<li><strong>单master</strong></li>\n</ol>\n<h2 id=\"GFS结构\"><a href=\"#GFS结构\" class=\"headerlink\" title=\"GFS结构\"></a>GFS结构</h2><p>master 存储元信息，chunk server 存储数据信息。两种服务器相互隔离</p>\n<h3 id=\"Master存储信息\"><a href=\"#Master存储信息\" class=\"headerlink\" title=\"Master存储信息\"></a>Master存储信息</h3><p>master中主要有两张表：</p>\n<ol>\n<li>filename-&gt; chunk handle（需要<strong>持久化</strong>）</li>\n<li>chunk handle-&gt;chunk servers</li>\n</ol>\n<ul>\n<li>chunk servers服务器列表：每个Chunk存储在哪些服务器上</li>\n<li>chunk版本号：每个Chunk当前的版本号（需要<strong>持久化</strong>）</li>\n<li>主chunk地址：所有对于Chunk的写操作都必须在主Chunk（Primary Chunk）上顺序处理，主Chunk是Chunk的多个副本之一。所以，Master节点必须记住哪个Chunk服务器持有主Chunk。</li>\n<li>主chunk租约到期时间：主Chunk只能在特定的租约时间内担任主Chunk，所以，Master节点要记住主Chunk的租约过期时间。</li>\n</ul>\n<p> 持久化的方式是<strong>写日志</strong>和<strong>打检查点</strong>。</p>\n<ul>\n<li>加入新chunk或者修改chunk版本时需要向磁盘写一条日志</li>\n<li>定时打checkpoints，将状态转移到磁盘中，恢复时选择最近的checkpoints，从该checkpoint后的日志开始恢复，而不必从猴年马月开始恢复。</li>\n</ul>\n<h2 id=\"Read读数据\"><a href=\"#Read读数据\" class=\"headerlink\" title=\"Read读数据\"></a>Read读数据</h2><h3 id=\"client和master-元信息交互\"><a href=\"#client和master-元信息交互\" class=\"headerlink\" title=\"client和master 元信息交互\"></a>client和master 元信息交互</h3><ol>\n<li>client 发送[filename文件名, offset偏移量]给master</li>\n<li>master从filename-&gt;chunk handle中查询<strong>chunk handle</strong>，offset &#x2F; chunk size 就是chunk handle在数组中的index，从而可以获取chunk handle</li>\n<li>master从chunk handle-&gt;chunk servers中查询<strong>chunk server</strong>的信息</li>\n<li>master将[chunk handle, chunk server]发送给client<br>client 会缓存 master返回的信息，因为可能会持续访问这个chunk<br>如果跨chunk访问，client端会自动分成两个读请求发给master</li>\n</ol>\n<h3 id=\"client和chunk-server-数据交互\"><a href=\"#client和chunk-server-数据交互\" class=\"headerlink\" title=\"client和chunk server 数据交互\"></a>client和chunk server 数据交互</h3><ol>\n<li>client 将[chunk handle, byte range]发送给选中的chunk server</li>\n<li>chunk server根据chunk handle找到文件，根据byte range获取数据，发回给client</li>\n</ol>\n<h2 id=\"Write写数据\"><a href=\"#Write写数据\" class=\"headerlink\" title=\"Write写数据\"></a>Write写数据</h2><p>GFS只追加数据，而不随机写数据。写数据时需要向持有primary chunk（主副本）的chunk server写入，当不清楚primary chunk时，需要进行以下操作</p>\n<h3 id=\"确定primary\"><a href=\"#确定primary\" class=\"headerlink\" title=\"确定primary\"></a>确定primary</h3><ol>\n<li>找到<strong>最新副本</strong>：chunk版本号&#x3D;&#x3D;master中记录chunk的版本号</li>\n<li>选中<strong>primary chunk</strong>：选择其中一个chunk server作为primary chunk，其他的就是secondary。primary是有租约的，超时过期就失去了primary的地位，为了避免同时出现两个primary，就算master联系不上primary，也会等待租约到期。</li>\n<li>版本号自增</li>\n<li>告诉chunk server，primary、secondary 版本号</li>\n<li>master写入版本号</li>\n</ol>\n<p>注意：</p>\n<ul>\n<li>版本号是master指定primary时才会产生的</li>\n</ul>\n<h2 id=\"客户端和primary的交互\"><a href=\"#客户端和primary的交互\" class=\"headerlink\" title=\"客户端和primary的交互\"></a>客户端和primary的交互</h2><ol>\n<li>客户端将数据往chunk server（primary &amp; secondary）发</li>\n<li>chunk server会将数据写入临时区，并给client返回确认信息</li>\n<li>client给primary发送确定信息，意义为：你和所有secondary都有了数据，请写入chunk末尾</li>\n<li>primary调度并发请求，并以某种顺序，保证一次只执行一个请求，给所有secondary发送写请求</li>\n<li>所有chunk server收到写请求后，将临时区的数据往chunk里写，完成后给primary发送确认信息，意义为：已经成功写入数据</li>\n<li>如果primary收到了所有secondary的确认消息，则返回给client确认消息，否则，若存在一个异常（secondary没有回复or回复错误信息），primary向client报告失败</li>\n<li>client收到失败信息后会重新发起数据追加操作</li>\n</ol>\n<p>写文件失败的一些事项</p>\n<ul>\n<li>部分chunk server确实写入了，所以存在读到新数据的可能</li>\n</ul>\n<h2 id=\"GFS一致性\"><a href=\"#GFS一致性\" class=\"headerlink\" title=\"GFS一致性\"></a>GFS一致性</h2><p>如果整套流程成功走下来，则系统各副本一致。<br>假如存在个别副本失败，则重新发一遍请求，在新的位置写入，所以读不同副本可能会读到不同的数据（有的可能有多套数据，有的可能只有一套，假如client也挂了，那可能存在一套数据都没有的副本）<br>多副本不一致，设计方式简单，但是容易出错。（有点拉）</p>\n","site":{"data":{}},"excerpt":"<p>Google File System，有点古老的技术，但技术仍存在参考意义</p>","more":"<h1 id=\"论文阅读\"><a href=\"#论文阅读\" class=\"headerlink\" title=\"论文阅读\"></a>论文阅读</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>Google有大量数据存储的要求，所以诞生了GFS这个大规模分布式文件存储系统。根据工作负载和技术环境，GFS和传统文件系统有以下区别：</p>\n<ol>\n<li><strong>组件故障是常态</strong> 分布式设备廉价容易出故障，而且不易恢复。</li>\n<li><strong>文件大</strong></li>\n<li><strong>修改&#x3D;&#x3D;追加</strong> 不存在对文件的随机写，一旦写入就不再修改，通过追加的方式进行修改</li>\n<li>多客户端可能同时对文件进行原子追加操作</li>\n<li>高带宽比低延迟更重要</li>\n</ol>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><p>GFS集群由1个<strong>Master</strong>、n个<strong>chunk server</strong>、m个client组成。<br>这些东西都跑在普通的Linux服务器上。chunk server和client是可以在同一台服务器上跑的。</p>\n<h3 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h3><ol>\n<li>文件会被分块，每一块叫做一个chunk。</li>\n<li>每个chunk有一个64位的唯一标识chunk handle，这个标识是在分块的时候由master产生的。</li>\n<li>文件存储在chunk server上，通过chunk handle和字节范围读写。</li>\n<li>文件会存在副本，可以设置不同命名空间中文件的不同副本数量</li>\n</ol>\n<h3 id=\"存储与交互\"><a href=\"#存储与交互\" class=\"headerlink\" title=\"存储与交互\"></a>存储与交互</h3><p>master存储文件系统的元信息，包括以下内容：</p>\n<ol>\n<li>名字空间 namespace（文件名）</li>\n<li>文件-&gt;块 映射信息</li>\n<li>chunk位置信息（不需要持久化）</li>\n<li>访问控制信息<br>master还控制了系统活动，如</li>\n<li>租约管理</li>\n<li>孤儿块垃圾回收</li>\n<li>chunk server之间的块迁移</li>\n<li>master用心跳信息管理chunk server状态<br>client绝不跟master要数据，而是向master要元信息，发送一个包含文件名和块索引的请求，master返回chunk handle和副本位置；然后client再向chunk master请求具体文件。<br>这么做保证了单master的可行性</li>\n</ol>\n<h1 id=\"课程记录\"><a href=\"#课程记录\" class=\"headerlink\" title=\"课程记录\"></a>课程记录</h1><h2 id=\"分布式存储的难点\"><a href=\"#分布式存储的难点\" class=\"headerlink\" title=\"分布式存储的难点\"></a>分布式存储的难点</h2><p>追求<strong>高性能</strong>-&gt;将文件<strong>分片</strong>放在多个服务器上-&gt;更容易发生<strong>故障</strong>-&gt;需要<strong>容错</strong>措施-&gt;建立<strong>副本</strong>-&gt;追求<strong>一致性</strong>*-&gt;<strong>低性能</strong></p>\n<h2 id=\"GFS特点\"><a href=\"#GFS特点\" class=\"headerlink\" title=\"GFS特点\"></a>GFS特点</h2><ol>\n<li><strong>单数据中心</strong>：只在一个数据中心运行</li>\n<li><strong>工业软件</strong>：不面向普通用户</li>\n<li><strong>大规模顺序读写</strong>：不支持随机访问，更关注吞吐量（带宽）而不是时延</li>\n<li><strong>弱一致性</strong>：保证性能</li>\n<li><strong>单master</strong></li>\n</ol>\n<h2 id=\"GFS结构\"><a href=\"#GFS结构\" class=\"headerlink\" title=\"GFS结构\"></a>GFS结构</h2><p>master 存储元信息，chunk server 存储数据信息。两种服务器相互隔离</p>\n<h3 id=\"Master存储信息\"><a href=\"#Master存储信息\" class=\"headerlink\" title=\"Master存储信息\"></a>Master存储信息</h3><p>master中主要有两张表：</p>\n<ol>\n<li>filename-&gt; chunk handle（需要<strong>持久化</strong>）</li>\n<li>chunk handle-&gt;chunk servers</li>\n</ol>\n<ul>\n<li>chunk servers服务器列表：每个Chunk存储在哪些服务器上</li>\n<li>chunk版本号：每个Chunk当前的版本号（需要<strong>持久化</strong>）</li>\n<li>主chunk地址：所有对于Chunk的写操作都必须在主Chunk（Primary Chunk）上顺序处理，主Chunk是Chunk的多个副本之一。所以，Master节点必须记住哪个Chunk服务器持有主Chunk。</li>\n<li>主chunk租约到期时间：主Chunk只能在特定的租约时间内担任主Chunk，所以，Master节点要记住主Chunk的租约过期时间。</li>\n</ul>\n<p> 持久化的方式是<strong>写日志</strong>和<strong>打检查点</strong>。</p>\n<ul>\n<li>加入新chunk或者修改chunk版本时需要向磁盘写一条日志</li>\n<li>定时打checkpoints，将状态转移到磁盘中，恢复时选择最近的checkpoints，从该checkpoint后的日志开始恢复，而不必从猴年马月开始恢复。</li>\n</ul>\n<h2 id=\"Read读数据\"><a href=\"#Read读数据\" class=\"headerlink\" title=\"Read读数据\"></a>Read读数据</h2><h3 id=\"client和master-元信息交互\"><a href=\"#client和master-元信息交互\" class=\"headerlink\" title=\"client和master 元信息交互\"></a>client和master 元信息交互</h3><ol>\n<li>client 发送[filename文件名, offset偏移量]给master</li>\n<li>master从filename-&gt;chunk handle中查询<strong>chunk handle</strong>，offset &#x2F; chunk size 就是chunk handle在数组中的index，从而可以获取chunk handle</li>\n<li>master从chunk handle-&gt;chunk servers中查询<strong>chunk server</strong>的信息</li>\n<li>master将[chunk handle, chunk server]发送给client<br>client 会缓存 master返回的信息，因为可能会持续访问这个chunk<br>如果跨chunk访问，client端会自动分成两个读请求发给master</li>\n</ol>\n<h3 id=\"client和chunk-server-数据交互\"><a href=\"#client和chunk-server-数据交互\" class=\"headerlink\" title=\"client和chunk server 数据交互\"></a>client和chunk server 数据交互</h3><ol>\n<li>client 将[chunk handle, byte range]发送给选中的chunk server</li>\n<li>chunk server根据chunk handle找到文件，根据byte range获取数据，发回给client</li>\n</ol>\n<h2 id=\"Write写数据\"><a href=\"#Write写数据\" class=\"headerlink\" title=\"Write写数据\"></a>Write写数据</h2><p>GFS只追加数据，而不随机写数据。写数据时需要向持有primary chunk（主副本）的chunk server写入，当不清楚primary chunk时，需要进行以下操作</p>\n<h3 id=\"确定primary\"><a href=\"#确定primary\" class=\"headerlink\" title=\"确定primary\"></a>确定primary</h3><ol>\n<li>找到<strong>最新副本</strong>：chunk版本号&#x3D;&#x3D;master中记录chunk的版本号</li>\n<li>选中<strong>primary chunk</strong>：选择其中一个chunk server作为primary chunk，其他的就是secondary。primary是有租约的，超时过期就失去了primary的地位，为了避免同时出现两个primary，就算master联系不上primary，也会等待租约到期。</li>\n<li>版本号自增</li>\n<li>告诉chunk server，primary、secondary 版本号</li>\n<li>master写入版本号</li>\n</ol>\n<p>注意：</p>\n<ul>\n<li>版本号是master指定primary时才会产生的</li>\n</ul>\n<h2 id=\"客户端和primary的交互\"><a href=\"#客户端和primary的交互\" class=\"headerlink\" title=\"客户端和primary的交互\"></a>客户端和primary的交互</h2><ol>\n<li>客户端将数据往chunk server（primary &amp; secondary）发</li>\n<li>chunk server会将数据写入临时区，并给client返回确认信息</li>\n<li>client给primary发送确定信息，意义为：你和所有secondary都有了数据，请写入chunk末尾</li>\n<li>primary调度并发请求，并以某种顺序，保证一次只执行一个请求，给所有secondary发送写请求</li>\n<li>所有chunk server收到写请求后，将临时区的数据往chunk里写，完成后给primary发送确认信息，意义为：已经成功写入数据</li>\n<li>如果primary收到了所有secondary的确认消息，则返回给client确认消息，否则，若存在一个异常（secondary没有回复or回复错误信息），primary向client报告失败</li>\n<li>client收到失败信息后会重新发起数据追加操作</li>\n</ol>\n<p>写文件失败的一些事项</p>\n<ul>\n<li>部分chunk server确实写入了，所以存在读到新数据的可能</li>\n</ul>\n<h2 id=\"GFS一致性\"><a href=\"#GFS一致性\" class=\"headerlink\" title=\"GFS一致性\"></a>GFS一致性</h2><p>如果整套流程成功走下来，则系统各副本一致。<br>假如存在个别副本失败，则重新发一遍请求，在新的位置写入，所以读不同副本可能会读到不同的数据（有的可能有多套数据，有的可能只有一套，假如client也挂了，那可能存在一套数据都没有的副本）<br>多副本不一致，设计方式简单，但是容易出错。（有点拉）</p>"},{"layout":"post","title":"分布式系统 MapReduce","date":"2023-09-17T15:12:24.000Z","_content":"第一课，分布式系统概述与mapreduce相关内容\n<!-- more -->\n# 论文阅读\n## MapReduce 背景\nMapReduce简介：MapReduce是一种编程模型，用于处理和生成大规模数据集。用户指定一个map函数，用于处理输入的键/值对，生成一组中间的键/值对；以及一个reduce函数，用于合并具有相同中间键的所有值。\nMapReduce实现：MapReduce利用用户定义的map和reduce函数，自动地将计算并行化并在大规模的集群上执行。运行时系统负责分割输入数据，调度程序在多台机器上执行，处理机器故障，以及管理机器间的通信。\nMapReduce应用：MapReduce可以表达许多实际中的任务，例如分布式grep、URL访问频率统计、反向链接图构建、词向量生成、倒排索引构建和分布式排序等。\nMapReduce类型：MapReduce的输入和输出都是键/值对的集合，但它们可以来自不同的域。中间的键/值对也是来自输出域的。用户可以使用字符串来转换不同类型的数据。\nMapReduce扩展：MapReduce提供了一些扩展功能，例如自定义分区函数、排序保证、组合函数、输入和输出类型、副作用处理、错误记录跳过、本地执行、状态信息和计数器等。\nMapReduce与其他并行计算模型的比较：MapReduce是一种简化和提炼了一些并行计算模型的编程模型，它根据Google的大规模实际计算的经验，自动地实现了并行化、容错、局部性优化和负载均衡。\nMapReduce与其他分布式系统的比较：MapReduce与一些提供高级抽象的分布式系统不同，它利用了一种受限的编程模型，使得用户程序可以自动地被并行化和容错。MapReduce还与一些针对特定应用的分布式系统不同，它提供了一个通用的库，可以用于各种类型的数据处理任务。\nMapReduce的灵感来源：MapReduce借鉴了一些技术，如主动磁盘、网络排序、分布式队列、数据分散和重复执行等，来提高性能、可扩展性和容错性。\nMapReduce的结论：MapReduce编程模型在Google被成功地用于多种目的，因为它易于使用、适用于多种问题、能够扩展到大量机器，并且有效地利用了机器资源。1作者从这项工作中学到了一些经验，如限制编程模型可以简化并行化和容错、网络带宽是稀缺资源、重复执行可以减少非均匀性的影响等。\n## MapReduce 运行逻辑\n可以理解为，将原有的多节点并行计算相关的操作封装了，只暴露了两个函数map和reduce，这两个函数由用户编写，注册到MapReduce框架中。\n### 基本思想\nsplit（数据分割）->map（数据转换）->shuffle（数据分类）->reduce（合并数据）\nMapReduce把所有的计算都拆分成两个基本的计算操作，即Map和Reduce。其中Map函数以一系列键值对作为输入，然后输出一个中间文件。这个中间态是另一种形式的键值对。最后，Reduce函数将这个中间态作为输入，计算得出结果。\n### 运作规则\n1. MapReduce客户端会将输入的文件会分为M个片段，每个片段的大小通常在 16~64 MB 之间。然后在多个机器上开始运行MapReduce程序。\n2. 系统中会有一个机器被选为Master节点，整个 MapReduce 计算包含M个Map 任务和R个 Reduce 任务。Master节点会为空闲的 Worker节点分配Map任务和 Reduce 任务\n3. 执行Map任务的 Worker开始读入自己对应的片段并将读入的数据解析为输入键值对。然后调用由用户定义的 Map任务。最后，Worker会将Map任务输出的结果存在内存中。\n4. 在执行Map的同时，Map Worker根据Partition 函数将产生的中间结果分为R个部分，然后定期将内存中的中间文件存入到自己的本地磁盘中。任务完成时，Mapper 便会将中间文件在其本地磁盘上的存放位置报告给 Master。\n5. Master会将中间文件存放位置通知给Reduce Work。Reduce Worker接收到这些信息后便会通过RPC读取中间文件。在读取完毕后，Reduce Worker会对读取到的数据进行排序，保证拥有相同键的键值对能够连续分布。\n6. 最后，Reduce Worker会为每个键收集与其关联的值的集合，并调用用户定义的Reduce 函数。Reduce 函数的结果会被放入到对应的结果文件。\n7. 当所有Map和Reduce都结束后，程序会换新客户端并返回结果。\n## 分布式容错方案\n分布式系统不可避免地要考虑容错的问题，在MapReduce中，容错也考虑Master和Work两种情况。\n### Master出错\nMaster节点会定期地将当前运行状态存为快照，当Master节点崩溃，就从最近的快照恢复然后重新执行任务。\n### worker出错\nMaster节点会定期地Ping每个Work节点，一旦发现Work节点不可达，针对其当前执行的是Map还是Reduce任务，会有不同的策略。\n1. Map任务，无论任务已完成或是未完成，都会废除当前节点的任务。Master会将任务重新分配给其他节点，同时由于已经生成的中间文件不可访问，还会通知还未拿到中间文件的Reduce Worker去新的节点拿数据。\n2. Reduce任务，由于结果文件存在GFS中，文件的可用性和一致性由GFS保证，所以Master仅将未完成的任务重新分配。\n## MapReduce优化策略\n简单来说就是调节负载\n如果集群中有某个 Worker 花了特别长的时间来完成最后的几个 Map 或 Reduce 任务，整个 MapReduce 计算任务的耗时就会因此被拖长，这样的 Worker 也就成了落后者。MapReduce 在整个计算完成到一定程度时就会将剩余的任务即同时将其分配给其他空闲 Worker 来执行，并在其中一个 Worker 完成后将该任务视作已完成。\n\n# 课堂笔记\n## 分布式系统需要克服的问题\n并行、容错性、通信物理距离、数据安全与隔离问题\n分布式系统的并发和错误是关键难点\n## 分布式系统的基础架构\n分布式的基础架构包括存储、通信、计算三个模块；希望能有抽象的接口，让分布式接口更接近非分布式的接口\n### 存储\n希望更抽象，容错、高性能\n### 通信\n网络通信 可靠性 详细内容见MIT6.829\n### 计算\n类似mapreduce\n## 分布式系统所需要的技术\n1. RPC：掩盖在非可靠网络上的事实\n2. 线程：并发\n3. 锁：并发\n## 分布式系统的性能目标\n### 可扩展性\n性能可扩展性，加硬件设备就能增加同规模的性能\n### 容错性\n1. 可用性：在出现了不可避免的故障后，系统仍能正常工作（冗余）\n2. 可恢复性：出现故障后，系统可以通过各种方式恢复到正常状态（非易失存储）\n### 一致性\n一致性包括强一致性和弱一致性，各有优劣\n1. 强一致性：每次读出的数据都是最新的\n2. 弱一致性：允许读出的数据没有被更新\n强一致性代价高，需要的通信成本高。尤其是副本数据存储物理距离较远时，通信成本将会限制强一致性的保证。所以弱一致性是工业界常用的技术。\n## MapReduce\n### 工作方式\n将分布式问题分为map和reduce两个函数，map将输入转换成中间键值对，reduce将中间键值对进行聚合计算。\n整个mapreduce的过程称为一个job（作业），一次mapreduce的过程称为一个task（任务）。\n### map函数\n```c++\n/*\nmap参数解释：key通常是不需要的，例如文件名、行号等，value是需要处理的，如文件实际内容\n*/\nmap(key, value) {\n    for each word in value:\n        emit(word, 1);\n    //对于value里的每一个单词，都需要将其组成一个新的key-value对发送\n    //map函数里的emit接受两个参数，就是key value\n}\n```\n### reduce函数\n```c++\n/*\nreduce的输入既是map函数的输出，相同的中间key会发送给同一个reduce函数\n*/\nreduce(key, value) {\n    emit(len(value));\n    // reduce里的emit通常只有一个输出参数\n}\n```\n\n# 实验\n在进行了一部分的go尝试后，虽然听说lab2用C++不好写，但还是决定拿起我的C++（果真是最爱），go语法有点怪怪的\n## 环境搭建\n在Windows物理机上使用wsl2安装Ubuntu18.04，按照[课程指引](https://pdos.csail.mit.edu/6.824/labs/lab-mr.html) 配置环境，值得注意的是，clone下来的代码跑不动的时候需要修改包的相对路径\n## 实验大体要求\n1. 两个程序 Coordinator(协调者)和Worker(工作者)，系统中有一个Coordinator和多个Worker进程并行执行。\n2. 进程间通信使用**RPC**进行，通信主要存在于coordinator和worker之间，通信内容是worker和coordinator之间的任务分发、数据来源地址、任务执行、输出写入地址\n3. 当coordinator发现worker长时间没有完成任务（10s）时，需要将该任务发布给其他worker\n## 详细规则\n1. map阶段应该将中间键分到不同的组里，将这些组传给**nReduce**个reduce任务。nReduce应该是MakeCoordinator()的参数（目前理解：建立Coordinator的时候就得指定有多少个reduce任务）\n2. worker执行reduce任务时输出文件名应该统一成mr-out-X（X是reduce任务的编号，[0, nReduce - 1]）\n3. mr-out-X文件中每行包含一个Reduce函数产生的结果，应该使用Go中的“%v %v”格式，来写入reduce后的key和value\n4. worker执行Map任务时，输出存到当前目录的文件，这样之后该文件作为reduce工作的输入能够被读到。\n5. 当所有工作结束，worker进程也应该退出。一个简单的办法是，每次调用call()函数时查看其返回值，如果返回值显示不能正常与coordinator通信，那么就假定工作已经结束且coordinator已经退出，因此worker也可以结束。这取决于你的设计，也可以设计\"please exit\"作为coordinator给worker的伪任务，来提提示worker的退出。\n## 论文细节描述\n1. MapReduce库首先将**输入文件分成M个片段**，每个片段通常为16到64兆字节（MB）（用户可以通过可选参数进行控制）。\n2. 在机群上启动多个程序。其中一个程序是特殊的，Master。其余的程序是由Master分配工作的Worker。有M个map任务和R个reduce任务需要分配。Master选择空闲的Worker，并为每个工作程序分配一个map任务或reduce任务。\n3. 被分配map任务的Worker读取相应输入片段的内容。它从输入数据中**解析**出键/值对，并将每个键/值对**传递**给用户定义的map函数。Map函数生成的中间键/值对在内存中进行缓冲。\n4. 定期将缓冲的键/值对按照分区函数**划分为R个区域**（需要排序吗？），并将这些缓冲区在本地磁盘上的位置传递回Master，由Master负责将这些位置转发给reducer。\n5. 当reducer收到Master关于这些位置的通知时，它使用**远程过程**调用从map工作程序的本地磁盘读取缓冲数据。当reducer读取所有中间数据时，它按照中间键对其进行**排序**，以便将相同键的所有出现组合在一起。如果中间数据量太大无法放入内存，则使用外部排序。\n6. reducer遍历排序后的中间数据，并对遇到的每个**唯一中间键**传递该键和相应的一组中间值给用户定义的reduce函数。Reduce函数的输出附加到此reduce分区的最终输出文件中。\n## 实验梳理\n### 结构\n1. Coordinator项目里有Coordinator和WorkerState，不必关心mapper和reducer的具体任务，只需要做分配调度的工作。其中Coordinator依赖WorkerState完成调度任务，WorkerState管理单个Worker\n2. worker项目里有Worker和Task及其子类，根据调用runTask的参数决定运行mapper还是reducer的任务\n### 功能\n1. Cooridinator不需要多实例运行。Cooridinator里需要创建一个worker池，将注册的不同worker放池子里，需要分配map、reduce任务时可以在池子里选一个worker运行，并修改其状态，该worker池需要考虑并发问题，写操作时加了一把大锁。\n2. Worker项目需要多实例运行，得多开，运行时需要传入参数决定其端口。\n3. Cooridinator和Worker通信时，注意端口不能硬编码，减少幻数\n4. 任务**Task**可以作为一个父类，**Map**和**Reduce**作为子类，实现run接口，由于传入参数不一样，故需要解析参数的不同接口parseArgs。\n## RPC补充信息\nRPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n本项目使用rest_rpc，配置过程如下\n### 安装boost\n1. 从[boost官网](https://www.boost.org/)上下载最新boost的zip版本\n2. 将压缩包解压到合适的路径\n3. 双击根目录下的bootstrap.bat文件，生成b2.exe\n4. 双击b2.exe运行\n5. VS studio 配置项目属性->VC++目录\n(1) \"包含目录\": boost的根目录，例:C:\\boost_1_79_0\n(2) \"库目录\": stage下的链接库目录，例:C:\\boost_1_79_0\\stage\\lib\n6. 配置属性->链接器->常规:\"附加库目录\":同上面的\"库目录\"，例:D:\\my_workspace\\C_program\\C_boost\\boost_1_79_0\\stage\\lib\n### 下载rest_rpc\n```bash\ngit clone https://github.com/qicosmos/rest_rpc\n```\n### 使用\n1. 在server和client端都需要引入rest_rpc.hpp，此处需要注意其目录，如`#include \"../rest_rpc/include/rest_rpc.hpp\"`\n2. 引入名字空间`using namespace rest_rpc;`\n3. server端：\n```c++\n//第一个参数必须得是conn\nstring hello(rpc_conn conn, string name) {\n\t/*可以为 void 返回类型，代表调用后不给远程客户端返回消息*/\n\treturn (\"Hello \" + name); /*返回给远程客户端的内容*/\n}\nint main() {\n\trpc_server server(9000, 6);\n\tserver.register_handler(\"func_greet\", hello);\n\tserver.run();//启动服务端\n\n\treturn 0;\n}\n```\n4. client端\n```c++\ntry {\n    /*建立连接*/\n    rpc_client client(\"127.0.0.1\", 9000);// IP 地址，端口号\n    /*设定超时 5s（不填默认为 3s），connect 超时返回 false，成功返回 true*/\n    bool has_connected = client.connect(5);\n    /*没有建立连接则退出程序*/\n    if (!has_connected) {\n        cout << \"connect timeout\" << endl;\n        exit(-1);\n    }\n\n    /*调用远程服务，返回欢迎信息*/\n    string result = client.call<std::string>(\"func_greet\", \"Lam\");// func_greet 为事先注册好的服务名，需要一个 name 参数，这里为 Hello Github 的缩写 HG\n    cout << result << endl;\n\n}\n/*遇到连接错误、调用服务时参数不对等情况会抛出异常*/\ncatch (const exception& e) {\n    cout << e.what() << endl;\n}\n```\n","source":"_posts/DS_Lecture1 mapreduce.md","raw":"---\nlayout: \ntitle: 分布式系统 MapReduce\ndate: 2023-09-17 23:12:24\ntags: \n - MapReduce\n - 分布式系统\n - mit 6.824\n---\n第一课，分布式系统概述与mapreduce相关内容\n<!-- more -->\n# 论文阅读\n## MapReduce 背景\nMapReduce简介：MapReduce是一种编程模型，用于处理和生成大规模数据集。用户指定一个map函数，用于处理输入的键/值对，生成一组中间的键/值对；以及一个reduce函数，用于合并具有相同中间键的所有值。\nMapReduce实现：MapReduce利用用户定义的map和reduce函数，自动地将计算并行化并在大规模的集群上执行。运行时系统负责分割输入数据，调度程序在多台机器上执行，处理机器故障，以及管理机器间的通信。\nMapReduce应用：MapReduce可以表达许多实际中的任务，例如分布式grep、URL访问频率统计、反向链接图构建、词向量生成、倒排索引构建和分布式排序等。\nMapReduce类型：MapReduce的输入和输出都是键/值对的集合，但它们可以来自不同的域。中间的键/值对也是来自输出域的。用户可以使用字符串来转换不同类型的数据。\nMapReduce扩展：MapReduce提供了一些扩展功能，例如自定义分区函数、排序保证、组合函数、输入和输出类型、副作用处理、错误记录跳过、本地执行、状态信息和计数器等。\nMapReduce与其他并行计算模型的比较：MapReduce是一种简化和提炼了一些并行计算模型的编程模型，它根据Google的大规模实际计算的经验，自动地实现了并行化、容错、局部性优化和负载均衡。\nMapReduce与其他分布式系统的比较：MapReduce与一些提供高级抽象的分布式系统不同，它利用了一种受限的编程模型，使得用户程序可以自动地被并行化和容错。MapReduce还与一些针对特定应用的分布式系统不同，它提供了一个通用的库，可以用于各种类型的数据处理任务。\nMapReduce的灵感来源：MapReduce借鉴了一些技术，如主动磁盘、网络排序、分布式队列、数据分散和重复执行等，来提高性能、可扩展性和容错性。\nMapReduce的结论：MapReduce编程模型在Google被成功地用于多种目的，因为它易于使用、适用于多种问题、能够扩展到大量机器，并且有效地利用了机器资源。1作者从这项工作中学到了一些经验，如限制编程模型可以简化并行化和容错、网络带宽是稀缺资源、重复执行可以减少非均匀性的影响等。\n## MapReduce 运行逻辑\n可以理解为，将原有的多节点并行计算相关的操作封装了，只暴露了两个函数map和reduce，这两个函数由用户编写，注册到MapReduce框架中。\n### 基本思想\nsplit（数据分割）->map（数据转换）->shuffle（数据分类）->reduce（合并数据）\nMapReduce把所有的计算都拆分成两个基本的计算操作，即Map和Reduce。其中Map函数以一系列键值对作为输入，然后输出一个中间文件。这个中间态是另一种形式的键值对。最后，Reduce函数将这个中间态作为输入，计算得出结果。\n### 运作规则\n1. MapReduce客户端会将输入的文件会分为M个片段，每个片段的大小通常在 16~64 MB 之间。然后在多个机器上开始运行MapReduce程序。\n2. 系统中会有一个机器被选为Master节点，整个 MapReduce 计算包含M个Map 任务和R个 Reduce 任务。Master节点会为空闲的 Worker节点分配Map任务和 Reduce 任务\n3. 执行Map任务的 Worker开始读入自己对应的片段并将读入的数据解析为输入键值对。然后调用由用户定义的 Map任务。最后，Worker会将Map任务输出的结果存在内存中。\n4. 在执行Map的同时，Map Worker根据Partition 函数将产生的中间结果分为R个部分，然后定期将内存中的中间文件存入到自己的本地磁盘中。任务完成时，Mapper 便会将中间文件在其本地磁盘上的存放位置报告给 Master。\n5. Master会将中间文件存放位置通知给Reduce Work。Reduce Worker接收到这些信息后便会通过RPC读取中间文件。在读取完毕后，Reduce Worker会对读取到的数据进行排序，保证拥有相同键的键值对能够连续分布。\n6. 最后，Reduce Worker会为每个键收集与其关联的值的集合，并调用用户定义的Reduce 函数。Reduce 函数的结果会被放入到对应的结果文件。\n7. 当所有Map和Reduce都结束后，程序会换新客户端并返回结果。\n## 分布式容错方案\n分布式系统不可避免地要考虑容错的问题，在MapReduce中，容错也考虑Master和Work两种情况。\n### Master出错\nMaster节点会定期地将当前运行状态存为快照，当Master节点崩溃，就从最近的快照恢复然后重新执行任务。\n### worker出错\nMaster节点会定期地Ping每个Work节点，一旦发现Work节点不可达，针对其当前执行的是Map还是Reduce任务，会有不同的策略。\n1. Map任务，无论任务已完成或是未完成，都会废除当前节点的任务。Master会将任务重新分配给其他节点，同时由于已经生成的中间文件不可访问，还会通知还未拿到中间文件的Reduce Worker去新的节点拿数据。\n2. Reduce任务，由于结果文件存在GFS中，文件的可用性和一致性由GFS保证，所以Master仅将未完成的任务重新分配。\n## MapReduce优化策略\n简单来说就是调节负载\n如果集群中有某个 Worker 花了特别长的时间来完成最后的几个 Map 或 Reduce 任务，整个 MapReduce 计算任务的耗时就会因此被拖长，这样的 Worker 也就成了落后者。MapReduce 在整个计算完成到一定程度时就会将剩余的任务即同时将其分配给其他空闲 Worker 来执行，并在其中一个 Worker 完成后将该任务视作已完成。\n\n# 课堂笔记\n## 分布式系统需要克服的问题\n并行、容错性、通信物理距离、数据安全与隔离问题\n分布式系统的并发和错误是关键难点\n## 分布式系统的基础架构\n分布式的基础架构包括存储、通信、计算三个模块；希望能有抽象的接口，让分布式接口更接近非分布式的接口\n### 存储\n希望更抽象，容错、高性能\n### 通信\n网络通信 可靠性 详细内容见MIT6.829\n### 计算\n类似mapreduce\n## 分布式系统所需要的技术\n1. RPC：掩盖在非可靠网络上的事实\n2. 线程：并发\n3. 锁：并发\n## 分布式系统的性能目标\n### 可扩展性\n性能可扩展性，加硬件设备就能增加同规模的性能\n### 容错性\n1. 可用性：在出现了不可避免的故障后，系统仍能正常工作（冗余）\n2. 可恢复性：出现故障后，系统可以通过各种方式恢复到正常状态（非易失存储）\n### 一致性\n一致性包括强一致性和弱一致性，各有优劣\n1. 强一致性：每次读出的数据都是最新的\n2. 弱一致性：允许读出的数据没有被更新\n强一致性代价高，需要的通信成本高。尤其是副本数据存储物理距离较远时，通信成本将会限制强一致性的保证。所以弱一致性是工业界常用的技术。\n## MapReduce\n### 工作方式\n将分布式问题分为map和reduce两个函数，map将输入转换成中间键值对，reduce将中间键值对进行聚合计算。\n整个mapreduce的过程称为一个job（作业），一次mapreduce的过程称为一个task（任务）。\n### map函数\n```c++\n/*\nmap参数解释：key通常是不需要的，例如文件名、行号等，value是需要处理的，如文件实际内容\n*/\nmap(key, value) {\n    for each word in value:\n        emit(word, 1);\n    //对于value里的每一个单词，都需要将其组成一个新的key-value对发送\n    //map函数里的emit接受两个参数，就是key value\n}\n```\n### reduce函数\n```c++\n/*\nreduce的输入既是map函数的输出，相同的中间key会发送给同一个reduce函数\n*/\nreduce(key, value) {\n    emit(len(value));\n    // reduce里的emit通常只有一个输出参数\n}\n```\n\n# 实验\n在进行了一部分的go尝试后，虽然听说lab2用C++不好写，但还是决定拿起我的C++（果真是最爱），go语法有点怪怪的\n## 环境搭建\n在Windows物理机上使用wsl2安装Ubuntu18.04，按照[课程指引](https://pdos.csail.mit.edu/6.824/labs/lab-mr.html) 配置环境，值得注意的是，clone下来的代码跑不动的时候需要修改包的相对路径\n## 实验大体要求\n1. 两个程序 Coordinator(协调者)和Worker(工作者)，系统中有一个Coordinator和多个Worker进程并行执行。\n2. 进程间通信使用**RPC**进行，通信主要存在于coordinator和worker之间，通信内容是worker和coordinator之间的任务分发、数据来源地址、任务执行、输出写入地址\n3. 当coordinator发现worker长时间没有完成任务（10s）时，需要将该任务发布给其他worker\n## 详细规则\n1. map阶段应该将中间键分到不同的组里，将这些组传给**nReduce**个reduce任务。nReduce应该是MakeCoordinator()的参数（目前理解：建立Coordinator的时候就得指定有多少个reduce任务）\n2. worker执行reduce任务时输出文件名应该统一成mr-out-X（X是reduce任务的编号，[0, nReduce - 1]）\n3. mr-out-X文件中每行包含一个Reduce函数产生的结果，应该使用Go中的“%v %v”格式，来写入reduce后的key和value\n4. worker执行Map任务时，输出存到当前目录的文件，这样之后该文件作为reduce工作的输入能够被读到。\n5. 当所有工作结束，worker进程也应该退出。一个简单的办法是，每次调用call()函数时查看其返回值，如果返回值显示不能正常与coordinator通信，那么就假定工作已经结束且coordinator已经退出，因此worker也可以结束。这取决于你的设计，也可以设计\"please exit\"作为coordinator给worker的伪任务，来提提示worker的退出。\n## 论文细节描述\n1. MapReduce库首先将**输入文件分成M个片段**，每个片段通常为16到64兆字节（MB）（用户可以通过可选参数进行控制）。\n2. 在机群上启动多个程序。其中一个程序是特殊的，Master。其余的程序是由Master分配工作的Worker。有M个map任务和R个reduce任务需要分配。Master选择空闲的Worker，并为每个工作程序分配一个map任务或reduce任务。\n3. 被分配map任务的Worker读取相应输入片段的内容。它从输入数据中**解析**出键/值对，并将每个键/值对**传递**给用户定义的map函数。Map函数生成的中间键/值对在内存中进行缓冲。\n4. 定期将缓冲的键/值对按照分区函数**划分为R个区域**（需要排序吗？），并将这些缓冲区在本地磁盘上的位置传递回Master，由Master负责将这些位置转发给reducer。\n5. 当reducer收到Master关于这些位置的通知时，它使用**远程过程**调用从map工作程序的本地磁盘读取缓冲数据。当reducer读取所有中间数据时，它按照中间键对其进行**排序**，以便将相同键的所有出现组合在一起。如果中间数据量太大无法放入内存，则使用外部排序。\n6. reducer遍历排序后的中间数据，并对遇到的每个**唯一中间键**传递该键和相应的一组中间值给用户定义的reduce函数。Reduce函数的输出附加到此reduce分区的最终输出文件中。\n## 实验梳理\n### 结构\n1. Coordinator项目里有Coordinator和WorkerState，不必关心mapper和reducer的具体任务，只需要做分配调度的工作。其中Coordinator依赖WorkerState完成调度任务，WorkerState管理单个Worker\n2. worker项目里有Worker和Task及其子类，根据调用runTask的参数决定运行mapper还是reducer的任务\n### 功能\n1. Cooridinator不需要多实例运行。Cooridinator里需要创建一个worker池，将注册的不同worker放池子里，需要分配map、reduce任务时可以在池子里选一个worker运行，并修改其状态，该worker池需要考虑并发问题，写操作时加了一把大锁。\n2. Worker项目需要多实例运行，得多开，运行时需要传入参数决定其端口。\n3. Cooridinator和Worker通信时，注意端口不能硬编码，减少幻数\n4. 任务**Task**可以作为一个父类，**Map**和**Reduce**作为子类，实现run接口，由于传入参数不一样，故需要解析参数的不同接口parseArgs。\n## RPC补充信息\nRPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。\n本项目使用rest_rpc，配置过程如下\n### 安装boost\n1. 从[boost官网](https://www.boost.org/)上下载最新boost的zip版本\n2. 将压缩包解压到合适的路径\n3. 双击根目录下的bootstrap.bat文件，生成b2.exe\n4. 双击b2.exe运行\n5. VS studio 配置项目属性->VC++目录\n(1) \"包含目录\": boost的根目录，例:C:\\boost_1_79_0\n(2) \"库目录\": stage下的链接库目录，例:C:\\boost_1_79_0\\stage\\lib\n6. 配置属性->链接器->常规:\"附加库目录\":同上面的\"库目录\"，例:D:\\my_workspace\\C_program\\C_boost\\boost_1_79_0\\stage\\lib\n### 下载rest_rpc\n```bash\ngit clone https://github.com/qicosmos/rest_rpc\n```\n### 使用\n1. 在server和client端都需要引入rest_rpc.hpp，此处需要注意其目录，如`#include \"../rest_rpc/include/rest_rpc.hpp\"`\n2. 引入名字空间`using namespace rest_rpc;`\n3. server端：\n```c++\n//第一个参数必须得是conn\nstring hello(rpc_conn conn, string name) {\n\t/*可以为 void 返回类型，代表调用后不给远程客户端返回消息*/\n\treturn (\"Hello \" + name); /*返回给远程客户端的内容*/\n}\nint main() {\n\trpc_server server(9000, 6);\n\tserver.register_handler(\"func_greet\", hello);\n\tserver.run();//启动服务端\n\n\treturn 0;\n}\n```\n4. client端\n```c++\ntry {\n    /*建立连接*/\n    rpc_client client(\"127.0.0.1\", 9000);// IP 地址，端口号\n    /*设定超时 5s（不填默认为 3s），connect 超时返回 false，成功返回 true*/\n    bool has_connected = client.connect(5);\n    /*没有建立连接则退出程序*/\n    if (!has_connected) {\n        cout << \"connect timeout\" << endl;\n        exit(-1);\n    }\n\n    /*调用远程服务，返回欢迎信息*/\n    string result = client.call<std::string>(\"func_greet\", \"Lam\");// func_greet 为事先注册好的服务名，需要一个 name 参数，这里为 Hello Github 的缩写 HG\n    cout << result << endl;\n\n}\n/*遇到连接错误、调用服务时参数不对等情况会抛出异常*/\ncatch (const exception& e) {\n    cout << e.what() << endl;\n}\n```\n","slug":"DS_Lecture1 mapreduce","published":1,"updated":"2023-09-30T06:51:36.269Z","comments":1,"photos":[],"link":"","_id":"clncyc9zg00090wt64tx29l9h","content":"<p>第一课，分布式系统概述与mapreduce相关内容</p>\n<span id=\"more\"></span>\n<h1 id=\"论文阅读\"><a href=\"#论文阅读\" class=\"headerlink\" title=\"论文阅读\"></a>论文阅读</h1><h2 id=\"MapReduce-背景\"><a href=\"#MapReduce-背景\" class=\"headerlink\" title=\"MapReduce 背景\"></a>MapReduce 背景</h2><p>MapReduce简介：MapReduce是一种编程模型，用于处理和生成大规模数据集。用户指定一个map函数，用于处理输入的键&#x2F;值对，生成一组中间的键&#x2F;值对；以及一个reduce函数，用于合并具有相同中间键的所有值。<br>MapReduce实现：MapReduce利用用户定义的map和reduce函数，自动地将计算并行化并在大规模的集群上执行。运行时系统负责分割输入数据，调度程序在多台机器上执行，处理机器故障，以及管理机器间的通信。<br>MapReduce应用：MapReduce可以表达许多实际中的任务，例如分布式grep、URL访问频率统计、反向链接图构建、词向量生成、倒排索引构建和分布式排序等。<br>MapReduce类型：MapReduce的输入和输出都是键&#x2F;值对的集合，但它们可以来自不同的域。中间的键&#x2F;值对也是来自输出域的。用户可以使用字符串来转换不同类型的数据。<br>MapReduce扩展：MapReduce提供了一些扩展功能，例如自定义分区函数、排序保证、组合函数、输入和输出类型、副作用处理、错误记录跳过、本地执行、状态信息和计数器等。<br>MapReduce与其他并行计算模型的比较：MapReduce是一种简化和提炼了一些并行计算模型的编程模型，它根据Google的大规模实际计算的经验，自动地实现了并行化、容错、局部性优化和负载均衡。<br>MapReduce与其他分布式系统的比较：MapReduce与一些提供高级抽象的分布式系统不同，它利用了一种受限的编程模型，使得用户程序可以自动地被并行化和容错。MapReduce还与一些针对特定应用的分布式系统不同，它提供了一个通用的库，可以用于各种类型的数据处理任务。<br>MapReduce的灵感来源：MapReduce借鉴了一些技术，如主动磁盘、网络排序、分布式队列、数据分散和重复执行等，来提高性能、可扩展性和容错性。<br>MapReduce的结论：MapReduce编程模型在Google被成功地用于多种目的，因为它易于使用、适用于多种问题、能够扩展到大量机器，并且有效地利用了机器资源。1作者从这项工作中学到了一些经验，如限制编程模型可以简化并行化和容错、网络带宽是稀缺资源、重复执行可以减少非均匀性的影响等。</p>\n<h2 id=\"MapReduce-运行逻辑\"><a href=\"#MapReduce-运行逻辑\" class=\"headerlink\" title=\"MapReduce 运行逻辑\"></a>MapReduce 运行逻辑</h2><p>可以理解为，将原有的多节点并行计算相关的操作封装了，只暴露了两个函数map和reduce，这两个函数由用户编写，注册到MapReduce框架中。</p>\n<h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><p>split（数据分割）-&gt;map（数据转换）-&gt;shuffle（数据分类）-&gt;reduce（合并数据）<br>MapReduce把所有的计算都拆分成两个基本的计算操作，即Map和Reduce。其中Map函数以一系列键值对作为输入，然后输出一个中间文件。这个中间态是另一种形式的键值对。最后，Reduce函数将这个中间态作为输入，计算得出结果。</p>\n<h3 id=\"运作规则\"><a href=\"#运作规则\" class=\"headerlink\" title=\"运作规则\"></a>运作规则</h3><ol>\n<li>MapReduce客户端会将输入的文件会分为M个片段，每个片段的大小通常在 16~64 MB 之间。然后在多个机器上开始运行MapReduce程序。</li>\n<li>系统中会有一个机器被选为Master节点，整个 MapReduce 计算包含M个Map 任务和R个 Reduce 任务。Master节点会为空闲的 Worker节点分配Map任务和 Reduce 任务</li>\n<li>执行Map任务的 Worker开始读入自己对应的片段并将读入的数据解析为输入键值对。然后调用由用户定义的 Map任务。最后，Worker会将Map任务输出的结果存在内存中。</li>\n<li>在执行Map的同时，Map Worker根据Partition 函数将产生的中间结果分为R个部分，然后定期将内存中的中间文件存入到自己的本地磁盘中。任务完成时，Mapper 便会将中间文件在其本地磁盘上的存放位置报告给 Master。</li>\n<li>Master会将中间文件存放位置通知给Reduce Work。Reduce Worker接收到这些信息后便会通过RPC读取中间文件。在读取完毕后，Reduce Worker会对读取到的数据进行排序，保证拥有相同键的键值对能够连续分布。</li>\n<li>最后，Reduce Worker会为每个键收集与其关联的值的集合，并调用用户定义的Reduce 函数。Reduce 函数的结果会被放入到对应的结果文件。</li>\n<li>当所有Map和Reduce都结束后，程序会换新客户端并返回结果。</li>\n</ol>\n<h2 id=\"分布式容错方案\"><a href=\"#分布式容错方案\" class=\"headerlink\" title=\"分布式容错方案\"></a>分布式容错方案</h2><p>分布式系统不可避免地要考虑容错的问题，在MapReduce中，容错也考虑Master和Work两种情况。</p>\n<h3 id=\"Master出错\"><a href=\"#Master出错\" class=\"headerlink\" title=\"Master出错\"></a>Master出错</h3><p>Master节点会定期地将当前运行状态存为快照，当Master节点崩溃，就从最近的快照恢复然后重新执行任务。</p>\n<h3 id=\"worker出错\"><a href=\"#worker出错\" class=\"headerlink\" title=\"worker出错\"></a>worker出错</h3><p>Master节点会定期地Ping每个Work节点，一旦发现Work节点不可达，针对其当前执行的是Map还是Reduce任务，会有不同的策略。</p>\n<ol>\n<li>Map任务，无论任务已完成或是未完成，都会废除当前节点的任务。Master会将任务重新分配给其他节点，同时由于已经生成的中间文件不可访问，还会通知还未拿到中间文件的Reduce Worker去新的节点拿数据。</li>\n<li>Reduce任务，由于结果文件存在GFS中，文件的可用性和一致性由GFS保证，所以Master仅将未完成的任务重新分配。</li>\n</ol>\n<h2 id=\"MapReduce优化策略\"><a href=\"#MapReduce优化策略\" class=\"headerlink\" title=\"MapReduce优化策略\"></a>MapReduce优化策略</h2><p>简单来说就是调节负载<br>如果集群中有某个 Worker 花了特别长的时间来完成最后的几个 Map 或 Reduce 任务，整个 MapReduce 计算任务的耗时就会因此被拖长，这样的 Worker 也就成了落后者。MapReduce 在整个计算完成到一定程度时就会将剩余的任务即同时将其分配给其他空闲 Worker 来执行，并在其中一个 Worker 完成后将该任务视作已完成。</p>\n<h1 id=\"课堂笔记\"><a href=\"#课堂笔记\" class=\"headerlink\" title=\"课堂笔记\"></a>课堂笔记</h1><h2 id=\"分布式系统需要克服的问题\"><a href=\"#分布式系统需要克服的问题\" class=\"headerlink\" title=\"分布式系统需要克服的问题\"></a>分布式系统需要克服的问题</h2><p>并行、容错性、通信物理距离、数据安全与隔离问题<br>分布式系统的并发和错误是关键难点</p>\n<h2 id=\"分布式系统的基础架构\"><a href=\"#分布式系统的基础架构\" class=\"headerlink\" title=\"分布式系统的基础架构\"></a>分布式系统的基础架构</h2><p>分布式的基础架构包括存储、通信、计算三个模块；希望能有抽象的接口，让分布式接口更接近非分布式的接口</p>\n<h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><p>希望更抽象，容错、高性能</p>\n<h3 id=\"通信\"><a href=\"#通信\" class=\"headerlink\" title=\"通信\"></a>通信</h3><p>网络通信 可靠性 详细内容见MIT6.829</p>\n<h3 id=\"计算\"><a href=\"#计算\" class=\"headerlink\" title=\"计算\"></a>计算</h3><p>类似mapreduce</p>\n<h2 id=\"分布式系统所需要的技术\"><a href=\"#分布式系统所需要的技术\" class=\"headerlink\" title=\"分布式系统所需要的技术\"></a>分布式系统所需要的技术</h2><ol>\n<li>RPC：掩盖在非可靠网络上的事实</li>\n<li>线程：并发</li>\n<li>锁：并发</li>\n</ol>\n<h2 id=\"分布式系统的性能目标\"><a href=\"#分布式系统的性能目标\" class=\"headerlink\" title=\"分布式系统的性能目标\"></a>分布式系统的性能目标</h2><h3 id=\"可扩展性\"><a href=\"#可扩展性\" class=\"headerlink\" title=\"可扩展性\"></a>可扩展性</h3><p>性能可扩展性，加硬件设备就能增加同规模的性能</p>\n<h3 id=\"容错性\"><a href=\"#容错性\" class=\"headerlink\" title=\"容错性\"></a>容错性</h3><ol>\n<li>可用性：在出现了不可避免的故障后，系统仍能正常工作（冗余）</li>\n<li>可恢复性：出现故障后，系统可以通过各种方式恢复到正常状态（非易失存储）</li>\n</ol>\n<h3 id=\"一致性\"><a href=\"#一致性\" class=\"headerlink\" title=\"一致性\"></a>一致性</h3><p>一致性包括强一致性和弱一致性，各有优劣</p>\n<ol>\n<li>强一致性：每次读出的数据都是最新的</li>\n<li>弱一致性：允许读出的数据没有被更新<br>强一致性代价高，需要的通信成本高。尤其是副本数据存储物理距离较远时，通信成本将会限制强一致性的保证。所以弱一致性是工业界常用的技术。</li>\n</ol>\n<h2 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h2><h3 id=\"工作方式\"><a href=\"#工作方式\" class=\"headerlink\" title=\"工作方式\"></a>工作方式</h3><p>将分布式问题分为map和reduce两个函数，map将输入转换成中间键值对，reduce将中间键值对进行聚合计算。<br>整个mapreduce的过程称为一个job（作业），一次mapreduce的过程称为一个task（任务）。</p>\n<h3 id=\"map函数\"><a href=\"#map函数\" class=\"headerlink\" title=\"map函数\"></a>map函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">map参数解释：key通常是不需要的，例如文件名、行号等，value是需要处理的，如文件实际内容</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">map</span>(key, value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each word in value:</span><br><span class=\"line\">        <span class=\"built_in\">emit</span>(word, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//对于value里的每一个单词，都需要将其组成一个新的key-value对发送</span></span><br><span class=\"line\">    <span class=\"comment\">//map函数里的emit接受两个参数，就是key value</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reduce函数\"><a href=\"#reduce函数\" class=\"headerlink\" title=\"reduce函数\"></a>reduce函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">reduce的输入既是map函数的输出，相同的中间key会发送给同一个reduce函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">reduce</span>(key, value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">emit</span>(<span class=\"built_in\">len</span>(value));</span><br><span class=\"line\">    <span class=\"comment\">// reduce里的emit通常只有一个输出参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><p>在进行了一部分的go尝试后，虽然听说lab2用C++不好写，但还是决定拿起我的C++（果真是最爱），go语法有点怪怪的</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>在Windows物理机上使用wsl2安装Ubuntu18.04，按照<a href=\"https://pdos.csail.mit.edu/6.824/labs/lab-mr.html\">课程指引</a> 配置环境，值得注意的是，clone下来的代码跑不动的时候需要修改包的相对路径</p>\n<h2 id=\"实验大体要求\"><a href=\"#实验大体要求\" class=\"headerlink\" title=\"实验大体要求\"></a>实验大体要求</h2><ol>\n<li>两个程序 Coordinator(协调者)和Worker(工作者)，系统中有一个Coordinator和多个Worker进程并行执行。</li>\n<li>进程间通信使用<strong>RPC</strong>进行，通信主要存在于coordinator和worker之间，通信内容是worker和coordinator之间的任务分发、数据来源地址、任务执行、输出写入地址</li>\n<li>当coordinator发现worker长时间没有完成任务（10s）时，需要将该任务发布给其他worker</li>\n</ol>\n<h2 id=\"详细规则\"><a href=\"#详细规则\" class=\"headerlink\" title=\"详细规则\"></a>详细规则</h2><ol>\n<li>map阶段应该将中间键分到不同的组里，将这些组传给<strong>nReduce</strong>个reduce任务。nReduce应该是MakeCoordinator()的参数（目前理解：建立Coordinator的时候就得指定有多少个reduce任务）</li>\n<li>worker执行reduce任务时输出文件名应该统一成mr-out-X（X是reduce任务的编号，[0, nReduce - 1]）</li>\n<li>mr-out-X文件中每行包含一个Reduce函数产生的结果，应该使用Go中的“%v %v”格式，来写入reduce后的key和value</li>\n<li>worker执行Map任务时，输出存到当前目录的文件，这样之后该文件作为reduce工作的输入能够被读到。</li>\n<li>当所有工作结束，worker进程也应该退出。一个简单的办法是，每次调用call()函数时查看其返回值，如果返回值显示不能正常与coordinator通信，那么就假定工作已经结束且coordinator已经退出，因此worker也可以结束。这取决于你的设计，也可以设计”please exit”作为coordinator给worker的伪任务，来提提示worker的退出。</li>\n</ol>\n<h2 id=\"论文细节描述\"><a href=\"#论文细节描述\" class=\"headerlink\" title=\"论文细节描述\"></a>论文细节描述</h2><ol>\n<li>MapReduce库首先将<strong>输入文件分成M个片段</strong>，每个片段通常为16到64兆字节（MB）（用户可以通过可选参数进行控制）。</li>\n<li>在机群上启动多个程序。其中一个程序是特殊的，Master。其余的程序是由Master分配工作的Worker。有M个map任务和R个reduce任务需要分配。Master选择空闲的Worker，并为每个工作程序分配一个map任务或reduce任务。</li>\n<li>被分配map任务的Worker读取相应输入片段的内容。它从输入数据中<strong>解析</strong>出键&#x2F;值对，并将每个键&#x2F;值对<strong>传递</strong>给用户定义的map函数。Map函数生成的中间键&#x2F;值对在内存中进行缓冲。</li>\n<li>定期将缓冲的键&#x2F;值对按照分区函数<strong>划分为R个区域</strong>（需要排序吗？），并将这些缓冲区在本地磁盘上的位置传递回Master，由Master负责将这些位置转发给reducer。</li>\n<li>当reducer收到Master关于这些位置的通知时，它使用<strong>远程过程</strong>调用从map工作程序的本地磁盘读取缓冲数据。当reducer读取所有中间数据时，它按照中间键对其进行<strong>排序</strong>，以便将相同键的所有出现组合在一起。如果中间数据量太大无法放入内存，则使用外部排序。</li>\n<li>reducer遍历排序后的中间数据，并对遇到的每个<strong>唯一中间键</strong>传递该键和相应的一组中间值给用户定义的reduce函数。Reduce函数的输出附加到此reduce分区的最终输出文件中。</li>\n</ol>\n<h2 id=\"实验梳理\"><a href=\"#实验梳理\" class=\"headerlink\" title=\"实验梳理\"></a>实验梳理</h2><h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><ol>\n<li>Coordinator项目里有Coordinator和WorkerState，不必关心mapper和reducer的具体任务，只需要做分配调度的工作。其中Coordinator依赖WorkerState完成调度任务，WorkerState管理单个Worker</li>\n<li>worker项目里有Worker和Task及其子类，根据调用runTask的参数决定运行mapper还是reducer的任务</li>\n</ol>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ol>\n<li>Cooridinator不需要多实例运行。Cooridinator里需要创建一个worker池，将注册的不同worker放池子里，需要分配map、reduce任务时可以在池子里选一个worker运行，并修改其状态，该worker池需要考虑并发问题，写操作时加了一把大锁。</li>\n<li>Worker项目需要多实例运行，得多开，运行时需要传入参数决定其端口。</li>\n<li>Cooridinator和Worker通信时，注意端口不能硬编码，减少幻数</li>\n<li>任务<strong>Task</strong>可以作为一个父类，<strong>Map</strong>和<strong>Reduce</strong>作为子类，实现run接口，由于传入参数不一样，故需要解析参数的不同接口parseArgs。</li>\n</ol>\n<h2 id=\"RPC补充信息\"><a href=\"#RPC补充信息\" class=\"headerlink\" title=\"RPC补充信息\"></a>RPC补充信息</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<br>本项目使用rest_rpc，配置过程如下</p>\n<h3 id=\"安装boost\"><a href=\"#安装boost\" class=\"headerlink\" title=\"安装boost\"></a>安装boost</h3><ol>\n<li>从<a href=\"https://www.boost.org/\">boost官网</a>上下载最新boost的zip版本</li>\n<li>将压缩包解压到合适的路径</li>\n<li>双击根目录下的bootstrap.bat文件，生成b2.exe</li>\n<li>双击b2.exe运行</li>\n<li>VS studio 配置项目属性-&gt;VC++目录<br>(1) “包含目录”: boost的根目录，例:C:\\boost_1_79_0<br>(2) “库目录”: stage下的链接库目录，例:C:\\boost_1_79_0\\stage\\lib</li>\n<li>配置属性-&gt;链接器-&gt;常规:”附加库目录”:同上面的”库目录”，例:D:\\my_workspace\\C_program\\C_boost\\boost_1_79_0\\stage\\lib</li>\n</ol>\n<h3 id=\"下载rest-rpc\"><a href=\"#下载rest-rpc\" class=\"headerlink\" title=\"下载rest_rpc\"></a>下载rest_rpc</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/qicosmos/rest_rpc</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>在server和client端都需要引入rest_rpc.hpp，此处需要注意其目录，如<code>#include &quot;../rest_rpc/include/rest_rpc.hpp&quot;</code></li>\n<li>引入名字空间<code>using namespace rest_rpc;</code></li>\n<li>server端：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个参数必须得是conn</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">hello</span><span class=\"params\">(rpc_conn conn, string name)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*可以为 void 返回类型，代表调用后不给远程客户端返回消息*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"string\">&quot;Hello &quot;</span> + name); <span class=\"comment\">/*返回给远程客户端的内容*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">rpc_server <span class=\"title\">server</span><span class=\"params\">(<span class=\"number\">9000</span>, <span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">\tserver.<span class=\"built_in\">register_handler</span>(<span class=\"string\">&quot;func_greet&quot;</span>, hello);</span><br><span class=\"line\">\tserver.<span class=\"built_in\">run</span>();<span class=\"comment\">//启动服务端</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>client端<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*建立连接*/</span></span><br><span class=\"line\">    <span class=\"function\">rpc_client <span class=\"title\">client</span><span class=\"params\">(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">9000</span>)</span></span>;<span class=\"comment\">// IP 地址，端口号</span></span><br><span class=\"line\">    <span class=\"comment\">/*设定超时 5s（不填默认为 3s），connect 超时返回 false，成功返回 true*/</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> has_connected = client.<span class=\"built_in\">connect</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*没有建立连接则退出程序*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!has_connected) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;connect timeout&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*调用远程服务，返回欢迎信息*/</span></span><br><span class=\"line\">    string result = client.<span class=\"built_in\">call</span>&lt;std::string&gt;(<span class=\"string\">&quot;func_greet&quot;</span>, <span class=\"string\">&quot;Lam&quot;</span>);<span class=\"comment\">// func_greet 为事先注册好的服务名，需要一个 name 参数，这里为 Hello Github 的缩写 HG</span></span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*遇到连接错误、调用服务时参数不对等情况会抛出异常*/</span></span><br><span class=\"line\"><span class=\"built_in\">catch</span> (<span class=\"type\">const</span> exception&amp; e) &#123;</span><br><span class=\"line\">    cout &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>第一课，分布式系统概述与mapreduce相关内容</p>","more":"<h1 id=\"论文阅读\"><a href=\"#论文阅读\" class=\"headerlink\" title=\"论文阅读\"></a>论文阅读</h1><h2 id=\"MapReduce-背景\"><a href=\"#MapReduce-背景\" class=\"headerlink\" title=\"MapReduce 背景\"></a>MapReduce 背景</h2><p>MapReduce简介：MapReduce是一种编程模型，用于处理和生成大规模数据集。用户指定一个map函数，用于处理输入的键&#x2F;值对，生成一组中间的键&#x2F;值对；以及一个reduce函数，用于合并具有相同中间键的所有值。<br>MapReduce实现：MapReduce利用用户定义的map和reduce函数，自动地将计算并行化并在大规模的集群上执行。运行时系统负责分割输入数据，调度程序在多台机器上执行，处理机器故障，以及管理机器间的通信。<br>MapReduce应用：MapReduce可以表达许多实际中的任务，例如分布式grep、URL访问频率统计、反向链接图构建、词向量生成、倒排索引构建和分布式排序等。<br>MapReduce类型：MapReduce的输入和输出都是键&#x2F;值对的集合，但它们可以来自不同的域。中间的键&#x2F;值对也是来自输出域的。用户可以使用字符串来转换不同类型的数据。<br>MapReduce扩展：MapReduce提供了一些扩展功能，例如自定义分区函数、排序保证、组合函数、输入和输出类型、副作用处理、错误记录跳过、本地执行、状态信息和计数器等。<br>MapReduce与其他并行计算模型的比较：MapReduce是一种简化和提炼了一些并行计算模型的编程模型，它根据Google的大规模实际计算的经验，自动地实现了并行化、容错、局部性优化和负载均衡。<br>MapReduce与其他分布式系统的比较：MapReduce与一些提供高级抽象的分布式系统不同，它利用了一种受限的编程模型，使得用户程序可以自动地被并行化和容错。MapReduce还与一些针对特定应用的分布式系统不同，它提供了一个通用的库，可以用于各种类型的数据处理任务。<br>MapReduce的灵感来源：MapReduce借鉴了一些技术，如主动磁盘、网络排序、分布式队列、数据分散和重复执行等，来提高性能、可扩展性和容错性。<br>MapReduce的结论：MapReduce编程模型在Google被成功地用于多种目的，因为它易于使用、适用于多种问题、能够扩展到大量机器，并且有效地利用了机器资源。1作者从这项工作中学到了一些经验，如限制编程模型可以简化并行化和容错、网络带宽是稀缺资源、重复执行可以减少非均匀性的影响等。</p>\n<h2 id=\"MapReduce-运行逻辑\"><a href=\"#MapReduce-运行逻辑\" class=\"headerlink\" title=\"MapReduce 运行逻辑\"></a>MapReduce 运行逻辑</h2><p>可以理解为，将原有的多节点并行计算相关的操作封装了，只暴露了两个函数map和reduce，这两个函数由用户编写，注册到MapReduce框架中。</p>\n<h3 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h3><p>split（数据分割）-&gt;map（数据转换）-&gt;shuffle（数据分类）-&gt;reduce（合并数据）<br>MapReduce把所有的计算都拆分成两个基本的计算操作，即Map和Reduce。其中Map函数以一系列键值对作为输入，然后输出一个中间文件。这个中间态是另一种形式的键值对。最后，Reduce函数将这个中间态作为输入，计算得出结果。</p>\n<h3 id=\"运作规则\"><a href=\"#运作规则\" class=\"headerlink\" title=\"运作规则\"></a>运作规则</h3><ol>\n<li>MapReduce客户端会将输入的文件会分为M个片段，每个片段的大小通常在 16~64 MB 之间。然后在多个机器上开始运行MapReduce程序。</li>\n<li>系统中会有一个机器被选为Master节点，整个 MapReduce 计算包含M个Map 任务和R个 Reduce 任务。Master节点会为空闲的 Worker节点分配Map任务和 Reduce 任务</li>\n<li>执行Map任务的 Worker开始读入自己对应的片段并将读入的数据解析为输入键值对。然后调用由用户定义的 Map任务。最后，Worker会将Map任务输出的结果存在内存中。</li>\n<li>在执行Map的同时，Map Worker根据Partition 函数将产生的中间结果分为R个部分，然后定期将内存中的中间文件存入到自己的本地磁盘中。任务完成时，Mapper 便会将中间文件在其本地磁盘上的存放位置报告给 Master。</li>\n<li>Master会将中间文件存放位置通知给Reduce Work。Reduce Worker接收到这些信息后便会通过RPC读取中间文件。在读取完毕后，Reduce Worker会对读取到的数据进行排序，保证拥有相同键的键值对能够连续分布。</li>\n<li>最后，Reduce Worker会为每个键收集与其关联的值的集合，并调用用户定义的Reduce 函数。Reduce 函数的结果会被放入到对应的结果文件。</li>\n<li>当所有Map和Reduce都结束后，程序会换新客户端并返回结果。</li>\n</ol>\n<h2 id=\"分布式容错方案\"><a href=\"#分布式容错方案\" class=\"headerlink\" title=\"分布式容错方案\"></a>分布式容错方案</h2><p>分布式系统不可避免地要考虑容错的问题，在MapReduce中，容错也考虑Master和Work两种情况。</p>\n<h3 id=\"Master出错\"><a href=\"#Master出错\" class=\"headerlink\" title=\"Master出错\"></a>Master出错</h3><p>Master节点会定期地将当前运行状态存为快照，当Master节点崩溃，就从最近的快照恢复然后重新执行任务。</p>\n<h3 id=\"worker出错\"><a href=\"#worker出错\" class=\"headerlink\" title=\"worker出错\"></a>worker出错</h3><p>Master节点会定期地Ping每个Work节点，一旦发现Work节点不可达，针对其当前执行的是Map还是Reduce任务，会有不同的策略。</p>\n<ol>\n<li>Map任务，无论任务已完成或是未完成，都会废除当前节点的任务。Master会将任务重新分配给其他节点，同时由于已经生成的中间文件不可访问，还会通知还未拿到中间文件的Reduce Worker去新的节点拿数据。</li>\n<li>Reduce任务，由于结果文件存在GFS中，文件的可用性和一致性由GFS保证，所以Master仅将未完成的任务重新分配。</li>\n</ol>\n<h2 id=\"MapReduce优化策略\"><a href=\"#MapReduce优化策略\" class=\"headerlink\" title=\"MapReduce优化策略\"></a>MapReduce优化策略</h2><p>简单来说就是调节负载<br>如果集群中有某个 Worker 花了特别长的时间来完成最后的几个 Map 或 Reduce 任务，整个 MapReduce 计算任务的耗时就会因此被拖长，这样的 Worker 也就成了落后者。MapReduce 在整个计算完成到一定程度时就会将剩余的任务即同时将其分配给其他空闲 Worker 来执行，并在其中一个 Worker 完成后将该任务视作已完成。</p>\n<h1 id=\"课堂笔记\"><a href=\"#课堂笔记\" class=\"headerlink\" title=\"课堂笔记\"></a>课堂笔记</h1><h2 id=\"分布式系统需要克服的问题\"><a href=\"#分布式系统需要克服的问题\" class=\"headerlink\" title=\"分布式系统需要克服的问题\"></a>分布式系统需要克服的问题</h2><p>并行、容错性、通信物理距离、数据安全与隔离问题<br>分布式系统的并发和错误是关键难点</p>\n<h2 id=\"分布式系统的基础架构\"><a href=\"#分布式系统的基础架构\" class=\"headerlink\" title=\"分布式系统的基础架构\"></a>分布式系统的基础架构</h2><p>分布式的基础架构包括存储、通信、计算三个模块；希望能有抽象的接口，让分布式接口更接近非分布式的接口</p>\n<h3 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h3><p>希望更抽象，容错、高性能</p>\n<h3 id=\"通信\"><a href=\"#通信\" class=\"headerlink\" title=\"通信\"></a>通信</h3><p>网络通信 可靠性 详细内容见MIT6.829</p>\n<h3 id=\"计算\"><a href=\"#计算\" class=\"headerlink\" title=\"计算\"></a>计算</h3><p>类似mapreduce</p>\n<h2 id=\"分布式系统所需要的技术\"><a href=\"#分布式系统所需要的技术\" class=\"headerlink\" title=\"分布式系统所需要的技术\"></a>分布式系统所需要的技术</h2><ol>\n<li>RPC：掩盖在非可靠网络上的事实</li>\n<li>线程：并发</li>\n<li>锁：并发</li>\n</ol>\n<h2 id=\"分布式系统的性能目标\"><a href=\"#分布式系统的性能目标\" class=\"headerlink\" title=\"分布式系统的性能目标\"></a>分布式系统的性能目标</h2><h3 id=\"可扩展性\"><a href=\"#可扩展性\" class=\"headerlink\" title=\"可扩展性\"></a>可扩展性</h3><p>性能可扩展性，加硬件设备就能增加同规模的性能</p>\n<h3 id=\"容错性\"><a href=\"#容错性\" class=\"headerlink\" title=\"容错性\"></a>容错性</h3><ol>\n<li>可用性：在出现了不可避免的故障后，系统仍能正常工作（冗余）</li>\n<li>可恢复性：出现故障后，系统可以通过各种方式恢复到正常状态（非易失存储）</li>\n</ol>\n<h3 id=\"一致性\"><a href=\"#一致性\" class=\"headerlink\" title=\"一致性\"></a>一致性</h3><p>一致性包括强一致性和弱一致性，各有优劣</p>\n<ol>\n<li>强一致性：每次读出的数据都是最新的</li>\n<li>弱一致性：允许读出的数据没有被更新<br>强一致性代价高，需要的通信成本高。尤其是副本数据存储物理距离较远时，通信成本将会限制强一致性的保证。所以弱一致性是工业界常用的技术。</li>\n</ol>\n<h2 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h2><h3 id=\"工作方式\"><a href=\"#工作方式\" class=\"headerlink\" title=\"工作方式\"></a>工作方式</h3><p>将分布式问题分为map和reduce两个函数，map将输入转换成中间键值对，reduce将中间键值对进行聚合计算。<br>整个mapreduce的过程称为一个job（作业），一次mapreduce的过程称为一个task（任务）。</p>\n<h3 id=\"map函数\"><a href=\"#map函数\" class=\"headerlink\" title=\"map函数\"></a>map函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">map参数解释：key通常是不需要的，例如文件名、行号等，value是需要处理的，如文件实际内容</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">map</span>(key, value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each word in value:</span><br><span class=\"line\">        <span class=\"built_in\">emit</span>(word, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">//对于value里的每一个单词，都需要将其组成一个新的key-value对发送</span></span><br><span class=\"line\">    <span class=\"comment\">//map函数里的emit接受两个参数，就是key value</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reduce函数\"><a href=\"#reduce函数\" class=\"headerlink\" title=\"reduce函数\"></a>reduce函数</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">reduce的输入既是map函数的输出，相同的中间key会发送给同一个reduce函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">reduce</span>(key, value) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">emit</span>(<span class=\"built_in\">len</span>(value));</span><br><span class=\"line\">    <span class=\"comment\">// reduce里的emit通常只有一个输出参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h1><p>在进行了一部分的go尝试后，虽然听说lab2用C++不好写，但还是决定拿起我的C++（果真是最爱），go语法有点怪怪的</p>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>在Windows物理机上使用wsl2安装Ubuntu18.04，按照<a href=\"https://pdos.csail.mit.edu/6.824/labs/lab-mr.html\">课程指引</a> 配置环境，值得注意的是，clone下来的代码跑不动的时候需要修改包的相对路径</p>\n<h2 id=\"实验大体要求\"><a href=\"#实验大体要求\" class=\"headerlink\" title=\"实验大体要求\"></a>实验大体要求</h2><ol>\n<li>两个程序 Coordinator(协调者)和Worker(工作者)，系统中有一个Coordinator和多个Worker进程并行执行。</li>\n<li>进程间通信使用<strong>RPC</strong>进行，通信主要存在于coordinator和worker之间，通信内容是worker和coordinator之间的任务分发、数据来源地址、任务执行、输出写入地址</li>\n<li>当coordinator发现worker长时间没有完成任务（10s）时，需要将该任务发布给其他worker</li>\n</ol>\n<h2 id=\"详细规则\"><a href=\"#详细规则\" class=\"headerlink\" title=\"详细规则\"></a>详细规则</h2><ol>\n<li>map阶段应该将中间键分到不同的组里，将这些组传给<strong>nReduce</strong>个reduce任务。nReduce应该是MakeCoordinator()的参数（目前理解：建立Coordinator的时候就得指定有多少个reduce任务）</li>\n<li>worker执行reduce任务时输出文件名应该统一成mr-out-X（X是reduce任务的编号，[0, nReduce - 1]）</li>\n<li>mr-out-X文件中每行包含一个Reduce函数产生的结果，应该使用Go中的“%v %v”格式，来写入reduce后的key和value</li>\n<li>worker执行Map任务时，输出存到当前目录的文件，这样之后该文件作为reduce工作的输入能够被读到。</li>\n<li>当所有工作结束，worker进程也应该退出。一个简单的办法是，每次调用call()函数时查看其返回值，如果返回值显示不能正常与coordinator通信，那么就假定工作已经结束且coordinator已经退出，因此worker也可以结束。这取决于你的设计，也可以设计”please exit”作为coordinator给worker的伪任务，来提提示worker的退出。</li>\n</ol>\n<h2 id=\"论文细节描述\"><a href=\"#论文细节描述\" class=\"headerlink\" title=\"论文细节描述\"></a>论文细节描述</h2><ol>\n<li>MapReduce库首先将<strong>输入文件分成M个片段</strong>，每个片段通常为16到64兆字节（MB）（用户可以通过可选参数进行控制）。</li>\n<li>在机群上启动多个程序。其中一个程序是特殊的，Master。其余的程序是由Master分配工作的Worker。有M个map任务和R个reduce任务需要分配。Master选择空闲的Worker，并为每个工作程序分配一个map任务或reduce任务。</li>\n<li>被分配map任务的Worker读取相应输入片段的内容。它从输入数据中<strong>解析</strong>出键&#x2F;值对，并将每个键&#x2F;值对<strong>传递</strong>给用户定义的map函数。Map函数生成的中间键&#x2F;值对在内存中进行缓冲。</li>\n<li>定期将缓冲的键&#x2F;值对按照分区函数<strong>划分为R个区域</strong>（需要排序吗？），并将这些缓冲区在本地磁盘上的位置传递回Master，由Master负责将这些位置转发给reducer。</li>\n<li>当reducer收到Master关于这些位置的通知时，它使用<strong>远程过程</strong>调用从map工作程序的本地磁盘读取缓冲数据。当reducer读取所有中间数据时，它按照中间键对其进行<strong>排序</strong>，以便将相同键的所有出现组合在一起。如果中间数据量太大无法放入内存，则使用外部排序。</li>\n<li>reducer遍历排序后的中间数据，并对遇到的每个<strong>唯一中间键</strong>传递该键和相应的一组中间值给用户定义的reduce函数。Reduce函数的输出附加到此reduce分区的最终输出文件中。</li>\n</ol>\n<h2 id=\"实验梳理\"><a href=\"#实验梳理\" class=\"headerlink\" title=\"实验梳理\"></a>实验梳理</h2><h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><ol>\n<li>Coordinator项目里有Coordinator和WorkerState，不必关心mapper和reducer的具体任务，只需要做分配调度的工作。其中Coordinator依赖WorkerState完成调度任务，WorkerState管理单个Worker</li>\n<li>worker项目里有Worker和Task及其子类，根据调用runTask的参数决定运行mapper还是reducer的任务</li>\n</ol>\n<h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><ol>\n<li>Cooridinator不需要多实例运行。Cooridinator里需要创建一个worker池，将注册的不同worker放池子里，需要分配map、reduce任务时可以在池子里选一个worker运行，并修改其状态，该worker池需要考虑并发问题，写操作时加了一把大锁。</li>\n<li>Worker项目需要多实例运行，得多开，运行时需要传入参数决定其端口。</li>\n<li>Cooridinator和Worker通信时，注意端口不能硬编码，减少幻数</li>\n<li>任务<strong>Task</strong>可以作为一个父类，<strong>Map</strong>和<strong>Reduce</strong>作为子类，实现run接口，由于传入参数不一样，故需要解析参数的不同接口parseArgs。</li>\n</ol>\n<h2 id=\"RPC补充信息\"><a href=\"#RPC补充信息\" class=\"headerlink\" title=\"RPC补充信息\"></a>RPC补充信息</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<br>本项目使用rest_rpc，配置过程如下</p>\n<h3 id=\"安装boost\"><a href=\"#安装boost\" class=\"headerlink\" title=\"安装boost\"></a>安装boost</h3><ol>\n<li>从<a href=\"https://www.boost.org/\">boost官网</a>上下载最新boost的zip版本</li>\n<li>将压缩包解压到合适的路径</li>\n<li>双击根目录下的bootstrap.bat文件，生成b2.exe</li>\n<li>双击b2.exe运行</li>\n<li>VS studio 配置项目属性-&gt;VC++目录<br>(1) “包含目录”: boost的根目录，例:C:\\boost_1_79_0<br>(2) “库目录”: stage下的链接库目录，例:C:\\boost_1_79_0\\stage\\lib</li>\n<li>配置属性-&gt;链接器-&gt;常规:”附加库目录”:同上面的”库目录”，例:D:\\my_workspace\\C_program\\C_boost\\boost_1_79_0\\stage\\lib</li>\n</ol>\n<h3 id=\"下载rest-rpc\"><a href=\"#下载rest-rpc\" class=\"headerlink\" title=\"下载rest_rpc\"></a>下载rest_rpc</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/qicosmos/rest_rpc</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><ol>\n<li>在server和client端都需要引入rest_rpc.hpp，此处需要注意其目录，如<code>#include &quot;../rest_rpc/include/rest_rpc.hpp&quot;</code></li>\n<li>引入名字空间<code>using namespace rest_rpc;</code></li>\n<li>server端：<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一个参数必须得是conn</span></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">hello</span><span class=\"params\">(rpc_conn conn, string name)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/*可以为 void 返回类型，代表调用后不给远程客户端返回消息*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (<span class=\"string\">&quot;Hello &quot;</span> + name); <span class=\"comment\">/*返回给远程客户端的内容*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\">rpc_server <span class=\"title\">server</span><span class=\"params\">(<span class=\"number\">9000</span>, <span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">\tserver.<span class=\"built_in\">register_handler</span>(<span class=\"string\">&quot;func_greet&quot;</span>, hello);</span><br><span class=\"line\">\tserver.<span class=\"built_in\">run</span>();<span class=\"comment\">//启动服务端</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>client端<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*建立连接*/</span></span><br><span class=\"line\">    <span class=\"function\">rpc_client <span class=\"title\">client</span><span class=\"params\">(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">9000</span>)</span></span>;<span class=\"comment\">// IP 地址，端口号</span></span><br><span class=\"line\">    <span class=\"comment\">/*设定超时 5s（不填默认为 3s），connect 超时返回 false，成功返回 true*/</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> has_connected = client.<span class=\"built_in\">connect</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*没有建立连接则退出程序*/</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!has_connected) &#123;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">&quot;connect timeout&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*调用远程服务，返回欢迎信息*/</span></span><br><span class=\"line\">    string result = client.<span class=\"built_in\">call</span>&lt;std::string&gt;(<span class=\"string\">&quot;func_greet&quot;</span>, <span class=\"string\">&quot;Lam&quot;</span>);<span class=\"comment\">// func_greet 为事先注册好的服务名，需要一个 name 参数，这里为 Hello Github 的缩写 HG</span></span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*遇到连接错误、调用服务时参数不对等情况会抛出异常*/</span></span><br><span class=\"line\"><span class=\"built_in\">catch</span> (<span class=\"type\">const</span> exception&amp; e) &#123;</span><br><span class=\"line\">    cout &lt;&lt; e.<span class=\"built_in\">what</span>() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>"},{"title":"算法：单调队列","date":"2023-09-17T14:38:02.000Z","_content":"一个比较神奇的算法，可以高效的解决区间最值问题\n<!--more-->\n# 算法核心\n只要有人比你年轻还比你强，那你就该离队了\n# 例题：滑动窗口最大值\n[leetcode链接](https://leetcode.cn/problems/sliding-window-maximum/description/)\n## 解析：\n从左向右遍历，建立一个递减的单调队列，定义为queue=[i1, i2, ..., in], i1 > i2 > ... > in。\n区间内的最大值一定是该队列的队头，否则，大于队头的值会将队头赶出该队列。\n## 样例解析\nnums = [1,3,-1,-3,5,3,6,7] k = 3\n| nums | 单调队列 | 说明 |\n| ---- | ---- | ---- |\n|{[(1)],3,-1,-3,5,3,6,7} | {1} | |\n|{[(1,3)],-1,-3,5,3,6,7} | {3} | (此时3入队，将1赶走)\n|{[(1,3,-1)],-3,5,3,6,7} | {3, -1} | |\n|{1,[(3,-1,-3)],5,3,6,7} | {3, -1， -3}  | |\n|{1,3,[(-1,-3,5)],3,6,7} | {5} |（3出队，同时5入队，将-3 -1依次赶走）|\n|{1,3,-1,[(-3,5,3)],6,7} | {5, 3} | |\n|{1,3,-1,-3,[(5,3,6)],7} | {6} | |\n|{1,3,-1,-3,5,[(3,6,7)]} | {7} | |\n## 代码\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> queue, ans;\n        queue.push_back(nums[0]);\n        for (int i = 1; i < nums.size(); ++i) {\n            if (i >= k) {\n                ans.push_back(queue.front());\n                if (queue[0] == nums[i - k]) queue.erase(queue.begin());\n            }\n            while (queue.size() && queue.back() < nums[i]) queue.pop_back();\n            if (!queue.size() || queue.back() >= nums[i]) queue.push_back(nums[i]);\n        }\n        ans.push_back(queue.front());\n        return ans;\n    }\n};\n```","source":"_posts/算法：单调队列.md","raw":"---\ntitle: 算法：单调队列\ndate: 2023-09-17 22:38:02\ntags:\n---\n一个比较神奇的算法，可以高效的解决区间最值问题\n<!--more-->\n# 算法核心\n只要有人比你年轻还比你强，那你就该离队了\n# 例题：滑动窗口最大值\n[leetcode链接](https://leetcode.cn/problems/sliding-window-maximum/description/)\n## 解析：\n从左向右遍历，建立一个递减的单调队列，定义为queue=[i1, i2, ..., in], i1 > i2 > ... > in。\n区间内的最大值一定是该队列的队头，否则，大于队头的值会将队头赶出该队列。\n## 样例解析\nnums = [1,3,-1,-3,5,3,6,7] k = 3\n| nums | 单调队列 | 说明 |\n| ---- | ---- | ---- |\n|{[(1)],3,-1,-3,5,3,6,7} | {1} | |\n|{[(1,3)],-1,-3,5,3,6,7} | {3} | (此时3入队，将1赶走)\n|{[(1,3,-1)],-3,5,3,6,7} | {3, -1} | |\n|{1,[(3,-1,-3)],5,3,6,7} | {3, -1， -3}  | |\n|{1,3,[(-1,-3,5)],3,6,7} | {5} |（3出队，同时5入队，将-3 -1依次赶走）|\n|{1,3,-1,[(-3,5,3)],6,7} | {5, 3} | |\n|{1,3,-1,-3,[(5,3,6)],7} | {6} | |\n|{1,3,-1,-3,5,[(3,6,7)]} | {7} | |\n## 代码\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> queue, ans;\n        queue.push_back(nums[0]);\n        for (int i = 1; i < nums.size(); ++i) {\n            if (i >= k) {\n                ans.push_back(queue.front());\n                if (queue[0] == nums[i - k]) queue.erase(queue.begin());\n            }\n            while (queue.size() && queue.back() < nums[i]) queue.pop_back();\n            if (!queue.size() || queue.back() >= nums[i]) queue.push_back(nums[i]);\n        }\n        ans.push_back(queue.front());\n        return ans;\n    }\n};\n```","slug":"算法：单调队列","published":1,"updated":"2023-09-17T15:05:12.095Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clncyc9zn000w0wt6a7uw5ct7","content":"<p>一个比较神奇的算法，可以高效的解决区间最值问题</p>\n<span id=\"more\"></span>\n<h1 id=\"算法核心\"><a href=\"#算法核心\" class=\"headerlink\" title=\"算法核心\"></a>算法核心</h1><p>只要有人比你年轻还比你强，那你就该离队了</p>\n<h1 id=\"例题：滑动窗口最大值\"><a href=\"#例题：滑动窗口最大值\" class=\"headerlink\" title=\"例题：滑动窗口最大值\"></a>例题：滑动窗口最大值</h1><p><a href=\"https://leetcode.cn/problems/sliding-window-maximum/description/\">leetcode链接</a></p>\n<h2 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a>解析：</h2><p>从左向右遍历，建立一个递减的单调队列，定义为queue&#x3D;[i1, i2, …, in], i1 &gt; i2 &gt; … &gt; in。<br>区间内的最大值一定是该队列的队头，否则，大于队头的值会将队头赶出该队列。</p>\n<h2 id=\"样例解析\"><a href=\"#样例解析\" class=\"headerlink\" title=\"样例解析\"></a>样例解析</h2><p>nums &#x3D; [1,3,-1,-3,5,3,6,7] k &#x3D; 3</p>\n<table>\n<thead>\n<tr>\n<th>nums</th>\n<th>单调队列</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>{[(1)],3,-1,-3,5,3,6,7}</td>\n<td>{1}</td>\n<td></td>\n</tr>\n<tr>\n<td>{[(1,3)],-1,-3,5,3,6,7}</td>\n<td>{3}</td>\n<td>(此时3入队，将1赶走)</td>\n</tr>\n<tr>\n<td>{[(1,3,-1)],-3,5,3,6,7}</td>\n<td>{3, -1}</td>\n<td></td>\n</tr>\n<tr>\n<td>{1,[(3,-1,-3)],5,3,6,7}</td>\n<td>{3, -1， -3}</td>\n<td></td>\n</tr>\n<tr>\n<td>{1,3,[(-1,-3,5)],3,6,7}</td>\n<td>{5}</td>\n<td>（3出队，同时5入队，将-3 -1依次赶走）</td>\n</tr>\n<tr>\n<td>{1,3,-1,[(-3,5,3)],6,7}</td>\n<td>{5, 3}</td>\n<td></td>\n</tr>\n<tr>\n<td>{1,3,-1,-3,[(5,3,6)],7}</td>\n<td>{6}</td>\n<td></td>\n</tr>\n<tr>\n<td>{1,3,-1,-3,5,[(3,6,7)]}</td>\n<td>{7}</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">maxSlidingWindow</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; queue, ans;</span><br><span class=\"line\">        queue.<span class=\"built_in\">push_back</span>(nums[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;= k) &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(queue.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (queue[<span class=\"number\">0</span>] == nums[i - k]) queue.<span class=\"built_in\">erase</span>(queue.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (queue.<span class=\"built_in\">size</span>() &amp;&amp; queue.<span class=\"built_in\">back</span>() &lt; nums[i]) queue.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!queue.<span class=\"built_in\">size</span>() || queue.<span class=\"built_in\">back</span>() &gt;= nums[i]) queue.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(queue.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一个比较神奇的算法，可以高效的解决区间最值问题</p>","more":"<h1 id=\"算法核心\"><a href=\"#算法核心\" class=\"headerlink\" title=\"算法核心\"></a>算法核心</h1><p>只要有人比你年轻还比你强，那你就该离队了</p>\n<h1 id=\"例题：滑动窗口最大值\"><a href=\"#例题：滑动窗口最大值\" class=\"headerlink\" title=\"例题：滑动窗口最大值\"></a>例题：滑动窗口最大值</h1><p><a href=\"https://leetcode.cn/problems/sliding-window-maximum/description/\">leetcode链接</a></p>\n<h2 id=\"解析：\"><a href=\"#解析：\" class=\"headerlink\" title=\"解析：\"></a>解析：</h2><p>从左向右遍历，建立一个递减的单调队列，定义为queue&#x3D;[i1, i2, …, in], i1 &gt; i2 &gt; … &gt; in。<br>区间内的最大值一定是该队列的队头，否则，大于队头的值会将队头赶出该队列。</p>\n<h2 id=\"样例解析\"><a href=\"#样例解析\" class=\"headerlink\" title=\"样例解析\"></a>样例解析</h2><p>nums &#x3D; [1,3,-1,-3,5,3,6,7] k &#x3D; 3</p>\n<table>\n<thead>\n<tr>\n<th>nums</th>\n<th>单调队列</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>{[(1)],3,-1,-3,5,3,6,7}</td>\n<td>{1}</td>\n<td></td>\n</tr>\n<tr>\n<td>{[(1,3)],-1,-3,5,3,6,7}</td>\n<td>{3}</td>\n<td>(此时3入队，将1赶走)</td>\n</tr>\n<tr>\n<td>{[(1,3,-1)],-3,5,3,6,7}</td>\n<td>{3, -1}</td>\n<td></td>\n</tr>\n<tr>\n<td>{1,[(3,-1,-3)],5,3,6,7}</td>\n<td>{3, -1， -3}</td>\n<td></td>\n</tr>\n<tr>\n<td>{1,3,[(-1,-3,5)],3,6,7}</td>\n<td>{5}</td>\n<td>（3出队，同时5入队，将-3 -1依次赶走）</td>\n</tr>\n<tr>\n<td>{1,3,-1,[(-3,5,3)],6,7}</td>\n<td>{5, 3}</td>\n<td></td>\n</tr>\n<tr>\n<td>{1,3,-1,-3,[(5,3,6)],7}</td>\n<td>{6}</td>\n<td></td>\n</tr>\n<tr>\n<td>{1,3,-1,-3,5,[(3,6,7)]}</td>\n<td>{7}</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">maxSlidingWindow</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; queue, ans;</span><br><span class=\"line\">        queue.<span class=\"built_in\">push_back</span>(nums[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;= k) &#123;</span><br><span class=\"line\">                ans.<span class=\"built_in\">push_back</span>(queue.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (queue[<span class=\"number\">0</span>] == nums[i - k]) queue.<span class=\"built_in\">erase</span>(queue.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (queue.<span class=\"built_in\">size</span>() &amp;&amp; queue.<span class=\"built_in\">back</span>() &lt; nums[i]) queue.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!queue.<span class=\"built_in\">size</span>() || queue.<span class=\"built_in\">back</span>() &gt;= nums[i]) queue.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans.<span class=\"built_in\">push_back</span>(queue.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"clncyc9z400010wt6ghnb0ifz","tag_id":"clncyc9zb00040wt6epw38k54","_id":"clncyc9zh000b0wt6a9fx1b81"},{"post_id":"clncyc9z400010wt6ghnb0ifz","tag_id":"clncyc9zg00080wt6af84b47a","_id":"clncyc9zh000c0wt6bfp3aao0"},{"post_id":"clncyc9z900030wt6av472ca3","tag_id":"clncyc9zh000a0wt6blng03yz","_id":"clncyc9zj000f0wt6dtqd17rj"},{"post_id":"clncyc9z900030wt6av472ca3","tag_id":"clncyc9zi000d0wt68exj8o53","_id":"clncyc9zj000g0wt66fl421tc"},{"post_id":"clncyc9zd00050wt623ntcf7d","tag_id":"clncyc9zb00040wt6epw38k54","_id":"clncyc9zk000k0wt6af6359oz"},{"post_id":"clncyc9zd00050wt623ntcf7d","tag_id":"clncyc9zg00080wt6af84b47a","_id":"clncyc9zk000l0wt6e72edxcy"},{"post_id":"clncyc9zd00050wt623ntcf7d","tag_id":"clncyc9zk000i0wt63war1oaj","_id":"clncyc9zl000n0wt61bcvd2bl"},{"post_id":"clncyc9zf00070wt69s8y5s2a","tag_id":"clncyc9zb00040wt6epw38k54","_id":"clncyc9zl000p0wt6b2l3d77m"},{"post_id":"clncyc9zf00070wt69s8y5s2a","tag_id":"clncyc9zk000j0wt6ekk82ui4","_id":"clncyc9zl000q0wt6488ifqwl"},{"post_id":"clncyc9zf00070wt69s8y5s2a","tag_id":"clncyc9zk000m0wt6hq387cfq","_id":"clncyc9zm000s0wt61rrec0wk"},{"post_id":"clncyc9zg00090wt64tx29l9h","tag_id":"clncyc9zl000o0wt67cou5uiq","_id":"clncyc9zm000t0wt6h0xsades"},{"post_id":"clncyc9zg00090wt64tx29l9h","tag_id":"clncyc9zk000j0wt6ekk82ui4","_id":"clncyc9zm000u0wt6f1ulh4d8"},{"post_id":"clncyc9zg00090wt64tx29l9h","tag_id":"clncyc9zb00040wt6epw38k54","_id":"clncyc9zm000v0wt64dfnf19w"}],"Tag":[{"name":"mit 6.824","_id":"clncyc9zb00040wt6epw38k54"},{"name":"容错","_id":"clncyc9zg00080wt6af84b47a"},{"name":"算法","_id":"clncyc9zh000a0wt6blng03yz"},{"name":"DP","_id":"clncyc9zi000d0wt68exj8o53"},{"name":"Raft","_id":"clncyc9zk000i0wt63war1oaj"},{"name":"分布式系统","_id":"clncyc9zk000j0wt6ekk82ui4"},{"name":"GFS","_id":"clncyc9zk000m0wt6hq387cfq"},{"name":"MapReduce","_id":"clncyc9zl000o0wt67cou5uiq"}]}}